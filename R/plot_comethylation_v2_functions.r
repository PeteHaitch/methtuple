# Peter Hickey
# 10/09/2012
# Plots of within-fragment comethylation
# This is version 2 and is a substantial re-write of the existing code.

#### TODOs ####
# Improve quantile plot titles to explicitly include what type of CpG-pairs are being shown - e.g. neighbours or not
# Density plots of all lors at a given IPD.
# Add faceting to quantile plots based on CpG-density and average methylation level in region
# Make read.wf parameters more resemble read.table

#### Load libraries used by these functions ####
library(ggplot2) # All plots are created with ggplot2
library(plyr) # I use plyr::rbind.fill in read.wf
library(GenomicRanges) 
library(reshape2) # I use reshape2::melt in lorQuantilePlot
library(BSgenome)
library('BSgenome.Hsapiens.UCSC.hg18') # Used to add seqlengths to the WF objects

#### ggplot2 plot options ####
presentation.theme <- theme(axis.text = element_text(size = 25, colour = 'black'), axis.title.x = element_text(size = 30), axis.title.y = element_text(size = 30, angle = 90, vjust = 0.4), strip.text.x = element_text(size = 25, face = 'italic'), strip.text.y = element_text(size = 25, angle = 270, face = 'italic'), plot.title = element_text(size = 35, face = 'bold'), legend.text = element_text(size = 20), legend.title = element_text(size = 25, face = 'bold'))

#### Function definitions ####
#' read.wf reads in a .wf file (generated by comethylation.py) and stores the result as a GRanges instance.
#'
#' @param sample.name is the name of the sample and should be the prefix of the .wf files
#' @param chromosomes determines for which chromosomes the .wf files are read in. chromosome.names is either a vector of chromosome names or the string "all" in which case all chromosomes except chrM are used (chrM is circular and breaks subsequent calls to findOverlaps).
#' @param pair.choice is 'all' or 'outermost' and determines which type of .wf files are read in.

#' @return a GRanges instance of CpG-pairs containing all .wf files as specified by the command line arguments
#' @keywords WF
#' @export
#' @examples
#' NULL
read.wf <- function(sample.name, chromosomes = 'all', pair.choice = 'all'){
  # Construct a list of chromosome names that are to have lag-correlations computed.
  if(chromosomes == 'all'){
    chromosome.list <- list('chr1', 'chr2', 'chr3', 'chr4', 'chr5', 'chr6', 'chr7', 'chr8', 'chr9', 'chr10', 'chr11', 'chr12', 'chr13',
                            'chr14', 'chr15', 'chr16', 'chr17', 'chr18', 'chr19', 'chr20', 'chr21', 'chr22', 'chrX', 'chrY')
    names(chromosome.list) <- chromosome.list
  } else{
    chromosome.list <- list(chromosomes)
    names(chromosome.list) <- chromosomes
  }
  wf.files <- list()
  for(chrom in names(chromosome.list)){
    if(pair.choice == 'all'){
      filename <- paste0(sample.name, '_', chrom, '.wf')
    } else if(pair.choice == 'outermost'){
      filename <- paste0(sample.name, '_', chrom, '_outermost.wf')
    }
    wf.files[[chrom]] <- read.table(filename, sep = '\t', stringsAsFactors = FALSE, header = TRUE)
  }
  wf.df <- rbind.fill(wf.files)
  wf.gr <- GRanges(seqnames = wf.df$chr, ranges = IRanges(start = wf.df$pos1, end = wf.df$pos2), counts = DataFrame(wf.df[, 4:15]))
  names(values(wf.gr)) <- substr(names(values(wf.gr)), start = 8, stop = 12) # Turns column names from e.g. "counts.MM" to "MM"
  seqlengths(wf.gr)[names(chromosome.list)] <- seqlengths(Hsapiens)[names(chromosome.list)]
  return(wf.gr)
}

#' lor computes the log odds ratio from an object returned by read.wf. Each CpG-pair gets assigned a log odds ratio (lor) and an asymptotic standard error (ase)
#' 
#' @param x is a data.frame created by coercing the DataFrame of MM, MU, UM and UU counts from the WF object to a data.frame
#' @param correct is TRUE or FALSE. Should the counts be "continuity corrected", i.e. add 0.5 to each count?
#' 
#' @return a data.frame of log odds ratios and their associated standard errors. Each row corresponds to the same row as the input.
#' @keywords lor
#' @export
#' @examples
#' NULL
lor <- function(x, correct = TRUE){
  if(correct){
    lor <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, log(x$MM + 0.5) + log(x$UU + 0.5) - log(x$MU + 0.5) - log(x$UM + 0.5))
    ase <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, sqrt(1 / (x$MM + 0.5) + 1 / (x$MU + 0.5) + 1 / (x$UM + 0.5) + 1 / (x$MU + 0.5)))
  } else{
    lor <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, log(x$MM) + log(x$UU) - log(x$MU) - log(x$UM))
    ase <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, sqrt(1 / x$MM + 1 / x$MU + 1 / x$UM + 1 / x$MU))
  }
  return(data.frame(lor = lor, ase = ase))
}

#' Computes aggregated log odds ratios from the CpG-pairs object. Aggregation can be done by intra-pair distance (IPD) and/or number of intervening CpGs (NIC). By default it aggregates by IPD.
#'
#' @param x is a "WF" object storing CpG-pairs
#' @param ipd is TRUE or FALSE. Should log odds ratios be aggregated by intra-pair distance?
#' @param nic is TRUE or FALSE. Should log ods ratios be aggregated by the number of intervening CpGs (NIC) in the CpG-pair?
#' @param correct is TRUE or FALSE. Should a continuity correction be performed for computation of log odds ratios?
#' 
#' @return a data.frame containing aggregated log odds ratio (and asymptotic standard errors) for each strata.
#' @keywords WF, lor
#' @export
#' @examples
#' NULL
aggregatedLor <- function(x, ipd = TRUE, nic = FALSE, correct = FALSE){
  if(ipd){
    ipd.values <- width(x) - 1 # -1 to make neighbouring CpGs (CGCG) have IPD = 2
  } else{
    ipd.values <- rep(-1, length(x)) # -1 is a FLAG that the 
  }
  if(nic){
    nic.values <- elementMetadata(x)$NIC
  } else{
    nic.values <- rep(-1, length(x))
  }
  y <- elementMetadata(x)
  aggregated <- aggregate.data.frame(x = data.frame(MM = y$MM, MU = y$MU, UM = y$UM, UU = y$UU), by = list(IPD = ipd.values, NIC = nic.values), FUN = sum)
  
  # Replace -1 flags with NAs
  aggregated$IPD[aggregated$IPD == -1] <- NA
  aggregated$NIC[aggregated$NIC == -1] <- NA
  
  # Compute log odds ratios and their asymptotic standard errors
  aggregated.lors <- cbind(IPD = aggregated$IPD, NIC = aggregated$NIC, lor(aggregated, correct = correct))
  return(aggregated.lors)
}
  
# Quantile plot of LORs as a function of a intra-pair separation from the WF.gr instance
#' Plot a quantile plot of individual CpG-pair log odds ratios as a function of IPD. WARNING: Currently uses fixed y-limits = [-4, 6]
#'
#' @param cpg.pairs is a GRanges instance of CpG-pairs and their associated log odds ratios
#' @param sample.name is a string of the sample's name
#' @param min.cov is the miniumum coverage required for a CpG-pair to be included in the plot
#' @param zero.nic is TRUE if the cpg.pairs contains only CpG-pairs with zero intervening CpGs (NIC)
#' @param pair.choice is either 'all' or 'outermost' depending on how the CpG-pairs were constructed
#' @param genomic.feature is a string describing what, if any, the CpG-pairs have been stratified by.
#' 
#' @return NULL
#' @keywords WF, lor
#' @export
#' @examples
#' NULL
lorQuantilePlot <- function(cpg.pairs, sample.name, min.cov, zero.nic, pair.choice, genomic.feature = NA, ...){
  cpg.pairs <- cpg.pairs[values(cpg.pairs)$cov >= min.cov, ]
  # A nasty kludge here to ensure q has the correct colnames. The tmp object is some bastard-hybrid of a 2 column data.frame, where the second column (x) is a named vector.
  tmp <- aggregate.data.frame(x = values(cpg.pairs)$lor, by = list(IPD = width(cpg.pairs) - 1), FUN = function(x){quantile(x, c(0.1, 0.25, 0.5, 0.75, 0.9), na.rm = TRUE, names = FALSE)})
  q <- as.data.frame(cbind(tmp$IPD, tmp$x))
  names(q) <- c('IPD', 'Q10', 'Q25', 'Q50', 'Q75', 'Q90')
  # q <- ddply(data.frame(IPD = width(cpg.pairs) - 1, lor = values(cpg.pairs)$lor), .variables = c('IPD'), function(x){quantile(x$lor, c(0.1, 0.25, 0.5, 0.75, 0.9), na.rm = TRUE)}, .parallel = FALSE) # Can do this in one step (and faster) with plyr
  
  # Reshape q from "wide" form to "long" form
  q.long <- melt(q, id.vars = 'IPD', variable.name = 'Quantile', value.name = 'lor')
  
  # Plot
  if(zero.nic){
    my.title <- paste0(sample.name, ': WF-comethylation (n = ', length(cpg.pairs), ')\nmin.cov = ', min.cov, ', pair.choice = ', pair.choice, ', NIC = 0')
  } else{
    my.title <- paste0(sample.name, ': WF-comethylation (n = ', length(cpg.pairs), ')\nmin.cov = ', min.cov, ', pair.choice = ', pair.choice)
  }
  if(!is.na(genomic.feature)){
    my.title <- paste0(my.title, ', ', genomic.feature)
  }
  qplot(x = IPD, y = lor, lty = Quantile, data = q.long, geom = "line", size = I(1.2), main = my.title, ylab = "Log odds ratio", xlab = "Distance between CpGs (bp)", ...) + scale_linetype_manual(name="Quantile",  values=c('Q10' = 3, 'Q25' = 2, 'Q50' = 1, 'Q75' = 2, 'Q90' = 3)) + presentation.theme # size = I(1.2) and not size = 1.2, otherwise size = 1.5 appears in the legend (http://stackoverflow.com/questions/3375984/how-to-adjust-line-size-in-geom-line-without-obtaining-another-useless-legend)
}

#' Density plot of all log odds ratios at a given IPD (can be multiple IPDs).
#'
#' @param cpg.pairs is a GRanges instance of CpG-pairs and their associated log odds ratios
#' @param sample.name is a string of the sample's name
#' @param min.cov is the miniumum coverage required for a CpG-pair to be included in the plot
#' @param ipd is a vector of IPD values. A density plot is generated for each IPD so it's best not to use to many (<7).
#' @param pair.type is the type of CpG-pairs. For example, outermost or all and neighbouring or overlapping. This is purely descriptive and is only used in plot titles.
#' 
#' @return NULL
#' @keywords WF, lor
#' @export
#' @examples
#' NULL
lorDensityPlot <- function(cpg.pairs, sample.name, min.cov, ipd, pair.type){
  # TODO: Make colour a continuous scale rather than discrete so I can use a colour gradient rather than qualtitative colours
  # TODO: Fix x-axis limits
  cpg.pairs <- cpg.pairs[values(cpg.pairs)$cov >= min.cov, ]
  cpg.pairs <- cpg.pairs[(width(cpg.pairs) - 1) %in% ipd, ]
  tmp <- data.frame(lor = values(cpg.pairs)$lor, IPD = (width(cpg.pairs) - 1))
  m <- ggplot(tmp, aes(x = lor, colour = factor(IPD)))
  m + geom_density(size = 2) + ggtitle(substitute(paste(sample.name, ' (pair-type = ', pair.type, '): min.cov = ', min.cov, sep = ''), list(sample.name = sample.name, pair.type = pair.type, min.cov = min.cov))) + scale_colour_discrete(name = 'IPD') + presentation.theme
}

#' Plot aggregated log odds ratios
#' 
#' @param lor.df is a data.frame of aggregated log odds ratios, as produced by aggregatedLor()
#' 
#' @return NULL
#' @keywords WF, lor, plot
#' @export
#' @examples
#' NULL
aggregateLorPlot <- function(lor.df, sample.name, zero.nic, pair.choice, genomic.feature = NA, ...){
  if(zero.nic){
    my.title <- paste0(sample.name, ': aggregated within-fragment comethylation\npair.choice = ', pair.choice, ', NIC = 0')
  } else{
    my.title <- my.title <- paste0(sample.name, ': aggregated within-fragment comethylation\npair.choice = ', pair.choice)
  } 
  if(!is.na(genomic.feature)){
    my.title <- paste0(my.title, ', ', genomic.feature)
  }
  qplot(x = IPD, y = lor, data = lor.df, size = I(1.2), main = my.title, ylab = "Log odds ratio", xlab = "Distance between CpGs (bp)", ...) + presentation.theme
}

  
