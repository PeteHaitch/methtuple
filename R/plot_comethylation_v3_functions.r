#### DESCRIPTION ####
# Peter Hickey
# 24/01/2013
# Functions used in creating plots of within-fragment comethylation
# This is version 3 and is a substantial re-write of the existing code to adapt it to the output of comethylation_v3.py

#### TODOs ####
# Pass BSgenome object as paramter to read.wf
# Improve quantile plot titles to explicitly include what type of CpG-pairs are being shown - e.g. neighbours or not
# Density plots of all lors at a given IPD.
# Add faceting to quantile plots based on CpG-density and average methylation level in region
# Make read.wf parameters more resemble read.table

#### Load libraries used by these functions ####
library(ggplot2) # All plots are created with ggplot2
library(plyr) # I use plyr::rbind.fill in read.wf
library(GenomicRanges) 
library(reshape2) # I use reshape2::melt in lorQuantilePlot
library(BSgenome)

#### ggplot2 plot options ####
presentation.theme <- theme(axis.text = element_text(size = 25, colour = 'black'), axis.title.x = element_text(size = 30), axis.title.y = element_text(size = 30, angle = 90, vjust = 0.4), strip.text.x = element_text(size = 25, face = 'italic'), strip.text.y = element_text(size = 25, angle = 270, face = 'italic'), plot.title = element_text(size = 35, face = 'bold'), legend.text = element_text(size = 20), legend.title = element_text(size = 25, face = 'bold'))



#### Function definitions ####
#' read.wf reads in a .wf file (generated by comethylation.py) and stores the result as a WF instance.
#'
#' @param sample.name is the name of the sample and should be the prefix of the .wf files
#' @param chromosomes determines for which chromosomes the .wf files are read in. chromosome.names is either a vector of chromosome names or the string "all" in which case all chromosomes except chrM are used (chrM is circular and breaks subsequent calls to findOverlaps).
#' @param pair.choice is 'all' or 'outermost' and determines which type of .wf files are read in.

#' @return a GRanges instance of CpG-pairs containing all .wf files as specified by the command line arguments
#' @keywords WF
#' @export
#' @examples
#' NULL
read.wf <- function(sample.name, chromosomes = 'all', pair.choice = 'all'){
  # Construct a list of chromosome names that are to have lag-correlations computed.
  if(chromosomes == 'all'){
    chromosome.list <- list('chr1', 'chr2', 'chr3', 'chr4', 'chr5', 'chr6', 'chr7', 'chr8', 'chr9', 'chr10', 'chr11', 'chr12', 'chr13',
                            'chr14', 'chr15', 'chr16', 'chr17', 'chr18', 'chr19', 'chr20', 'chr21', 'chr22', 'chrX', 'chrY')
    names(chromosome.list) <- chromosome.list
  } else{
    chromosome.list <- list(chromosomes)
    names(chromosome.list) <- chromosomes
  }
  wf.files <- list()
  for(chrom in names(chromosome.list)){
    if(pair.choice == 'all'){
      filename <- paste0(sample.name, '_', chrom, '.wf')
    } else if(pair.choice == 'outermost'){
      filename <- paste0(sample.name, '_', chrom, '_outermost.wf')
    }
    wf.files[[chrom]] <- read.table(filename, sep = '\t', stringsAsFactors = FALSE, header = TRUE)
  }
  wf.df <- rbind.fill(wf.files)
  wf.gr <- GRanges(seqnames = wf.df$chr, ranges = IRanges(start = wf.df$pos1, end = wf.df$pos2), counts = DataFrame(wf.df[, 4:15]))
  names(values(wf.gr)) <- substr(names(values(wf.gr)), start = 8, stop = 12) # Turns column names from e.g. "counts.MM" to "MM"
  seqlengths(wf.gr)[names(chromosome.list)] <- seqlengths(Hsapiens)[names(chromosome.list)]
  return(wf.gr)
}