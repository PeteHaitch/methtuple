#!/usr/bin/python
import re
from numpy import array
import argparse
import sys
import csv
import pysam
import warnings
from operator import itemgetter, attrgetter

## This program is Copyright (C) 2012, Peter Hickey (hickey@wehi.edu.au)

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.

### Program description ###
############################################################################################################################################################################################
# Extract within-fragment co-methylation measurements at CpGs for the aligned reads from a BS-Seq experiment.
# SAM/BAM must be generated by Bismark. Other aligners will be supported in future releases. The SAM/BAM file must comply with the SAM spec (v1.4). The Bismark SAM file does not comply with these standards and must be pre-processed with correct_Bismark.py. The reason for this is that the Bismark SAM file does not correctly encode the orientation of read-pairs in the SAM flag field.
# The SAM/BAM can contain single-end reads, paired-end reads or a combination of the two types. The type of sequencing performed is determined by checking whether the 0x01 flag bit is set ("template being sequenced has multiple fragments"). SAM/BAM files containing paired-end reads must be sorted by query-name using Picard's SortSam function.
# CpGs are identified by examining the XM-tag of each read. The XM-tag is reference-based, so only reference Cpgs are examined. This means that sample-specific CpGs are ignored and reference-specific CpGs, which may not be CpGs in the sample of interest, are also examined.
# This program brings together the functionality of SAM2MS.py and QS_PE_SAM2MS.py and summarise_MS.py.
# There are two types of comethylation: (1) Within-fragment co-methylation (WF), which is the dependence of methylation states along a DNA read/fragment/chromosome that contains multiple Cpgs; and (2) correlation of aggregate methylation values (AM). Aggregate methylation values are based on the pileup of reads at each CpG and include beta = M/(U+M) and gamma = log((M + eps)/(U + eps)), where M = the number of methylated Cs, U = the number of unmethylated Cs and esp is a small number to ensure numerical stability of gamma, typically esp = 0.5.
# co-methylation extracts the necessary information to analyse (1), it does not perform the statistical analysis. A sister program, aggregate_methylation.py, extracts the necessary information to analyse (2).
# If the reads from a read-pair overlap then, provided the overlapping sequence is identical, we trim the lower quality read until no overlap remains. If the overlapping sequence is not identical then we ignore the read-pair. This behaviour may be altered in future releases.
############################################################################################################################################################################################

### Description of sample.wf ###
############################################################################################################################################################################################
# Each line corresponds to a CpG-pair and includes a count of the number of methylated Cs (M), unmethylated Cs (U) and other bases (other) for that CpG.
# CpG-pairs can be created in several ways, see comethylation.py --help for details. Each pair is defined as (CpG1, CpG2), where CpG1 is the leftmost CpG in the pair and CpG2 is the rightmost CpG in the pair (with reference to Watson-strand coordinates).
# The data for each CpG-pair are stratified by which strand the reads aligned to: Original Top (OT) aka Watson-strand aka forward-strand aka "+"-strand; Original Bottom (OB) aka Crick-strand aka reverse-strand aka "-"-strand and combined across strands.
# The strand information is encoded as a subscript, e.g. MM_OT is the count of reads informative for the OT-strand that are methylated at both CpGs in the CpG-pair, MU_OB is the count of reads informative for the OB-strand that are methylated at CpG1 and unmethylated at CpG2, UU (no subscript) is the count of reads, combined across strands, that are unmethylated at both CpGs in the CpG-pair.
############################################################################################################################################################################################

### Explanation of XM-tag (methylation string) ###
############################################################################################################################################################################################
# . for bases not involving cytosines                       
# X for methylated C in CHG context (was protected)         
# x for not methylated C in CHG context (was converted)     
# H for methylated C in CHH context (was protected)         
# h for not methylated C in CHH context (was converted)     
# Z for methylated C in CpG context (was protected)         
# z for not methylated C in CpG context (was converted)
# U for methylated C in "unknown" context, e.g. CNN-context, (was protected). Non-standard Bismark XM-tag values; unique to output of XM_tag.py.
# u for not methylated C in "unknown"-context, e.g. CNN-context, (was converted). Non-standard Bismark XM-tag values; unique to output of XM_tag.py.
############################################################################################################################################################################################

### TODOs ###
############################################################################################################################################################################################
# See Google Docs "Issue tracker - comethylation.py v2" (https://docs.google.com/spreadsheet/ccc?key=0Au0uDiAd9OV9dHN1SUZPc1Ixa2oyTjZnQVlEYVZ1QlE)
############################################################################################################################################################################################

### Command line parser ###
############################################################################################################################################################################################
parser = argparse.ArgumentParser(description='Extract within-fragment co-methylation measurements at CpGs from the aligned reads of a BS-Seq experiment. WARNING: Currently only works for the two-strand BS-seq protocol for reads without soft-clipping or indels and requires Bismark-style BAM files including XG-, XR- and XM-tags.')
parser.add_argument('BAM', metavar = 'BAM',
                    help ='The path to the SAM/BAM file')
parser.add_argument('sampleName',
                    metavar = 'sampleName',
                    help = 'The name of the sample. All output files will have this prefix.')
parser.add_argument('--ignoreDuplicates',
                    action = 'store_true',
                    help ='Ignore reads that have been flagged as PCR duplicates by Picard\'s MarkDuplicates function')
parser.add_argument('--ignoreStart', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Ignore first <int> bases from start of reads, where start is the first sequenced base not necessarily the leftmost aligned base (default: 0). WARNING: Parameter value not sanity checked by program.')
parser.add_argument('--ignoreEnd', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Ignore last <int> bases from end of reads, where end is the last sequenced base not necessarily the rightmost aligned base (default: 0). WARNING: Parameter value not sanity checked by program.')
parser.add_argument('--minQual', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Minimum base-quality (default: 0). Any base with a lower base-quality is ignored.')
parser.add_argument('--pairChoice',
                    metavar = '<string>',
                    default ="outermost",
                    help='Method for constructing CpG-pairs: outermost or all (default: outermost)')
parser.add_argument('--methylationType',
                    metavar = '<string>',
                    default ="CpG",
                    help='The type of methylation sites to study: CG or CHH (default: CG)')
parser.add_argument('--phred64',
                    action = 'store_true',
                    help='Quality scores are encoded as Phred64 (default: Phred33)')
parser.add_argument('--skipIdenticalOverlapCheck',
                    action = 'store_true',
                    help = 'WARNING: This option is not recommended and will likely give erroneous results. Skip the check of whether the overlapping sequences from an overlapping readpair are identical.')
parser.add_argument('--version',
                    action='version', version='%(prog)s 2.0')

args = parser.parse_args()
############################################################################################################################################################################################

### Open SAM/BAM file and output files ###
############################################################################################################################################################################################
BAM = pysam.Samfile(args.BAM)
WF = open(".".join([args.sampleName, "wf"]), "w")
############################################################################################################################################################################################

### Function definitions ###
#############################################################################################################################################################################################
def ignore_first_n_bases(read, methylation_index, n):
    """Ignore methylation sites occuring in the first n bases of a read. A methylation site may be one of CpG, CHH, CHG or CNN.

    Args:
        read: A pysam.AlignedRead instance.
        methylation_index: A list of zero-based indices. Each index corresponds to the leftmost aligned position of a methylation site in a read. For example:

        [0, 5]

        corresponds to a read with a methylation site at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.

    Returns:
        An updated version of methylation_index.
    """
    ignore_these_bases = []
    # Single-end reads
    if not read.is_paired:
        # Read aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        # Read aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_1
    elif read.is_paired and read.is_read1:
        # read_1 aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        # read_1 aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_2
    elif read.is_paired and read.is_read2:
        # read_2 aligned to OT-strand <------|
        if read.opt('XG') == 'CT' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        # read_2 aligned to OB-strand |------>
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Skipping read because it does not have necessary information to infer whether read is paired or whether the read is read_1 or read_2 of the pair.
    else:
        warning_msg = ''.join(['Skipping read ', read.qname, '. Missing 0x01, 0x40 or 0x80 FLAG bit (paired-read FLAG information)'])
        warnings.warn(warning_msg)
        methylation_index = []
    return [x for x in methylation_index if x not in ignore_these_bases]

def ignore_last_n_bases(read, methylation_index, n):
    """Ignore methylation sites occuring in the last n bases of a read. A methylation site may be one of CpG, CHH, CHG or CNN.

    Args:
        read: A pysam.AlignedRead instance.
        methylation_index: A list of zero-based indices. Each index corresponds to the leftmost aligned position of a methylation site in a read. For example:

        [0, 5]

        corresponds to a read with a methylation site at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.

    Returns:
        An updated version of methylation_index.
    """
    ignore_these_bases = []
    # Single-end reads
    if not read.is_paired:
        # Read aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        # Read aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_1
    elif read.is_paired and read.is_read1:
        # read_1 aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        # read_1 aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_2
    elif read.is_paired and read.is_read2:
        # read_2 aligned to OT-strand <------|
        if read.opt('XG') == 'CT' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        # read_2 aligned to OB-strand |------>
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i  >= (read.alen - n):
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Skipping read because it does not have necessary information to infer whether read is paired or whether the read is read_1 or read_2 of the pair.
    else:
        warning_msg = ''.join(['Skipping read ', read.qname, '. Missing 0x01, 0x40 or 0x80 FLAG bit (paired-read FLAG information)'])
        warnings.warn(warning_msg)
        methylation_index = []
    return [x for x in methylation_index if x not in ignore_these_bases]
        
def ignore_low_quality_bases(read, methylation_index, min_qual, phred_offset):
    """Ignore low quality bases of a read that contribute to a read's methylation_index.

    Args:
        read: A pysam.AlignedRead instance.
        methylation_index: A list of zero-based indices. Each index corresponds to the leftmost aligned position of a methylation site in a read. For example:

        [0, 5]

        corresponds to a read with a methylation site at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.
        min_qual: The minimum base quality (integer). All bases with quality < min_qual are excluded from the returned methylation_index instance.
        phred_offset: The Phred offset of the data (33 or 64).

    Returns:
        An updated version of methylation_index.
    
    """
    ignore_these_bases = []
    for i in methylation_index:
        if (ord(read.qual[i]) - phred_offset) < min_qual:
            ignore_these_bases.append(i)
    return [x for x in methylation_index if x not in ignore_these_bases]

def is_overlapping_sequence_identical(read_1, read_2, n_overlap):
    """Check whether the overlapping sequence of read_1 and read_2 is identical.

    Args:
        read_1: A pysam.AlignedRead instance with read.is_read1 == true. Must be paired with read_2.
        read_2: A pysam.AlignedRead instance with read.is_read2 == true. Must be paired with read_1.
        n_overlap: The number of bases in the overlap of read_1 and read_2 (must be > 0)

    Returns:
        True if the overlapping sequence is identical, False otherwise (NB: this means that readpairs that trigger the warning for having mis-specified XG- or XR-tags will also return 'False').
    """
    # Readpair aligns to OT-strand
    if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_1 = read_1.seq[-n_overlap:]
        overlap_2 = read_2.seq[:n_overlap]
    # Readpair aligns to OB-strand
    elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_1 = read_1.seq[:n_overlap]
        overlap_2 = read_2.seq[-n_overlap]
    else:
        warning_msg = ''.join(['XG-tags or XR-tags for readpair ', read.qname, ' are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
        warnings.warn(warning_msg)
        overlap_1 = True
        overlap_2 = False
    return overlap_1 == overlap_2

def ignore_overlapping_sequence(read_1, read_2, methylation_index_1, methylation_index_2, n_overlap):
    """Ignore the overlapping sequence of read_1 and read_2 from the read with the lower (sum) base qualities in the overlapping region.
       If base qualities are identical then (arbitrarily) ignore the overlapping bases from read_2.

    Args:
        read_1: A pysam.AlignedRead instance with read.is_read1 == true. Must be paired with read_2.
        read_2: A pysam.AlignedRead instance with read.is_read2 == true. Must be paired with read_1.
        methylation_index_1: A list of zero-based indices.  Each index corresponds to the leftmost aligned position of a methylation site in read_1. For example:

        [0, 5]

        corresponds to read_1 with a methylation site at the first and sixth positions of the read.
        methylation_index_2: As for methylation_index_1 but informative for read_2.
        n_overlap: The number of bases in the overlap (must be > 0).

    Returns:
        Updated versions of methylation_index_1 and methylation_index_2.
    """
    ignore_these_bases = []
    # Readpair aligns to OT-strand
    if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_quals_1 = sum([ord(x) for x in read_1.qual[-n_overlap:]])
        overlap_quals_2 = sum([ord(x) for x in read_2.qual[-n_overlap:]])
        if overlap_quals_1 >= overlap_quals_2:
            for i in methylation_index_2:
                if i < n_overlap:
                    ignore_these_bases.append(i)
                    methylation_index_2 = [x for x in methylation_index_2 if x not in ignore_these_bases]
        else:
            for i in methylation_index_1:
                if i >= (read.alen - n_overlap):
                    ignore_these_bases.append(i)
                    methylation_index_1 = [x for x in methylation_index_1 if x not in ignore_these_bases]
    # Readpair aligns to OB-strand
    elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_quals_1 = sum([ord(x) for x in read_1.qual[:n_overlap]])
        overlap_quals_2 = sum([ord(x) for x in read_2.qual[-n_overlap:]])
        if overlap_quals_1 >= overlap_quals_2:
            for i in methylation_index_2:
                if i >= (read_2.alen - n_overlap):
                    ignore_these_bases.append(i)
                    methylation_index_2 = [x for x in methylation_index_2 if x not in ignore_these_bases]
        else:
            for i in methylation_index_1:
                if i < n_overlap:
                    ignore_these_bases.append(i)
                    methylation_index_1 = [x for x in methylation_index_1 if x not in ignore_these_bases]
    else:
        warning_msg = ''.join(['Skipping readpair ', read.qname, ' as XG-tags or XR-tags are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
        warnings.warn(warning_msg)
        methylation_index_1 = []
        methylation_index_2 = []
    return methylation_index_1, methylation_index_2

def create_chromosome_index(chromosome_name):
    chromosome_key = {'chr1': 1, 'chr2': 2, 'chr3': 3, 'chr4': 4, 'chr5': 5, 'chr6': 6, 'chr7': 7, 'chr8': 8, 'chr9': 9, 'chr10': 10, 'chr11': 11, 'chr12': 12, 'chr13': 13, 'chr14': 14, 'chr15': 15, 'chr16': 16, 'chr17': 17, 'chr18': 18, 'chr19': 19, 'chr20': 20, 'chr21': 21, 'chr22': 22, 'chrX': 23, 'chrY': 24, 'chrM': 25, 'chrL': 26}
    return chromosome_key[chromosome_name]

class WithinFragmentComethylationPair:
    """A WithinFragmentComethylationPair instance stores the within-fragment comethylation counts for a single pair of methylation sites, e.g. a CpG-pair.
    
    Attributes:
        chromosome: The chromosome containing the pair.
        chromosome_index: An index to be used when sorting a set of WithinFragmentComethylationPair instances by chromosome name.
        position_1 = The 1-based position of the leftmost methylation site in the pair (with reference to the OT-strand). NB: position_1 < position_2 by definition.
        position_2 = The 1-based position of the rightmost methylation site in the pair (with reference to the OT-strand). NB: position_1 < position_2 by definition.
        counts: A dictionary storing the counts for each of the four comethylation states stratified by the strand (2 levels) or combined across strand (1 level), giving a total of twelve keys and associated values (counts).
    """
    def __init__(self, chromosome, chromosome_index, position_1, position_2, methylation_type):
        """Initiates WithinFragmentComethylationPair for a single pair of methylation events with co-ordinates given by arguments (chromosome, position_1, position_2) and sets all counts to zero."""
        self.methylation_type = methylation_type
        self.chromosome = chromosome
        self.chromosome_index = chromosome_index
        self.position_1 = position_1
        self.position_2 = position_2
        self.counts = {'MM': 0, 'MU': 0, 'UM': 0, 'UU': 0, 'MM_OT': 0, 'MU_OT': 0, 'UM_OT': 0, 'UU_OT': 0, 'MM_OB': 0, 'MU_OB': 0, 'UM_OB': 0, 'UU_OB': 0}
    def display(self):
        """Display a WithinFragmentComethylationPair instance."""
        print ''.join(['Methylation type = ', self.methylation_type])
        print ''.join(['Position = ', self.chromosome, ':', str(self.position_1), '-', str(self.position_2)])
        print 'Counts =', self.counts
    def pair_id(self):
        print ''.join([self.chromosome, ':', str(self.position_1), '-', str(self.position_2)])
    def increment_count(self, comethylation_state, read_1, read_2):
        """Increment the counts attribute based on the comethylation_state that has been extracted from read_1 and read_2. NB: read_2 should be set to None if data is single-end."""
        # Single-end
        if read_2 is None:
            # Read aligns to OT-strand
            if read_1.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and not read_1.is_paired:
                if comethylation_state == MM:
                    self.counts['MM'] += 1
                    self.counts['MM_OT'] += 1
                elif comethylation_state == MU:
                    self.counts['MU'] += 1
                    self.counts['MU_OT'] += 1
                elif comethylation_state == UM:
                    self.counts['UM'] += 1
                    self.counts['UM_OT'] += 1
                elif comethylation_state == UU:
                    self.counts['UU'] += 1
                    self.counts['UU_OT'] += 1
                else:
                    exit_msg = ''.join(['Error: Invalid methylation string (',  comethylation_state, ') for read:', read_1.qname])
                    sys.exit(exit_msg)
            # Read aligns to OB-strand
            elif read_1.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and not read_1.is_paired:
                if comethylation_state == MM:
                    self.counts['MM'] += 1
                    self.counts['MM_OB'] += 1
                elif comethylation_state == MU:
                    self.counts['MU'] += 1
                    self.counts['MU_OB'] += 1
                elif comethylation_state == UM:
                    self.counts['UM'] += 1
                    self.counts['UM_OB'] += 1
                elif comethylation_state == UU:
                    self.counts['UU'] += 1
                    self.counts['UU_OB'] += 1
                else:
                    exit_msg = ''.join(['Error: Invalid methylation string (',  comethylation_state, ') for read:', read_1.qname])
                    sys.exit(exit_msg)
            # Read does not align to either OT-strand or OB-strand so skip it.
            else:
                warning_msg = ''.join(['Skipping read ', read.qname, ' as XG-tags or XR-tags are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
                warnings.warn(warning_msg)
                print read_1
                print read_2
        else:
            # Readpair aligns to OT-strand
            if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA' and read_1.is_paired and read_2.is_paired:
                if comethylation_state == MM:
                    self.counts['MM'] += 1
                    self.counts['MM_OT'] += 1
                elif comethylation_state == MU:
                    self.counts['MU'] += 1
                    self.counts['MU_OT'] += 1
                elif comethylation_state == UM:
                    self.counts['UM'] += 1
                    self.counts['UM_OT'] += 1
                elif comethylation_state == UU:
                    self.counts['UU'] += 1
                    self.counts['UU_OT'] += 1
                else:
                    exit_msg = ''.join(['Error: Invalid methylation string (',  comethylation_state, ') for readpair:', read_1.qname])
                    sys.exit(exit_msg)
            # Readpair aligns to OB-strand
            elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA' and read_1.is_paired and read_2.is_paired:
                if comethylation_state == MM:
                    self.counts['MM'] += 1
                    self.counts['MM_OB'] += 1
                elif comethylation_state == MU:
                    self.counts['MU'] += 1
                    self.counts['MU_OB'] += 1
                elif comethylation_state == UM:
                    self.counts['UM'] += 1
                    self.counts['UM_OB'] += 1
                elif comethylation_state == UU:
                    self.counts['UU'] += 1
                    self.counts['UU_OB'] += 1
                else:
                    exit_msg = ''.join(['Error: Invalid methylation string (',  comethylation_state, ') for readpair:', read_1.qname])
                    sys.exit(exit_msg)
            # Readpair (paired-end) or read (single-end) does not align to either OT-strand or OB-strand so skip it.
            else:
                warning_msg = ''.join(['Skipping readpair ', read.qname, ' as XG-tags or XR-tags are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
                warnings.warn(warning_msg)             


def extract_and_update_methylation_index_from_single_end_read(read, BAM, methylation_pairs, pair_choice):
    """Extracts pairs of methylation sites from a single-end read and adds the comethylation states to the methylation_pairs object.
    
    Args:
        read: An AlignedRead instance corresponding to a single-end read.
        BAM: The Samfile instance corresponding to the sample. Required in order to extract chromosome names from read.
        methylation_pairs: A dictionary storing all observed pairs of methylation events and their WithinFragmentComethylationPair instance. An exmaple of a pair of methylation sites is a CpG-pair. 
        pair_choice: A string indicating how the pairs of methylation sites are to be constructed: "all" (all possible pairs) or "outermost" (the pair with the largest intra-pair distance). NB: "outermost" ensures each read is only used once in the within-fragment comethylation analysis.
    Returns:
        methylation_pairs: An updated version of methylation_pairs
        n_methylation_sites: The number of methylation sites extracted from the read.
    """
    # Identify methylation events in read, e.g. CpGs or CHHs. The methylation_pattern is specified by a command line argument (e.g. Z/z corresponds to CpG)
    methylation_index = [m.start() for m in re.finditer(methylation_pattern, read.opt('XM'))]
    # Ignore any start or end positions of read, as specified by command line arguments
    if args.ignoreStart > 0:
        methylation_index = ignore_first_n_bases(read, methylation_index, args.ignoreStart)
    if args.ignoreEnd > 0:
        methylation_index = ignore_last_n_bases(read, methylation_index, args.ignoreEnd)
    # Ignore any positions with a base quality less than the args.minQual, as specified by command line arguments
    methylation_index = ignore_low_quality_bases(read, methylation_index, args.minQual, phred_offset)
    n_methylation_sites = len(methylation_index)
    # Case A: > 1 methylation site in the read
    if n_methylation_sites > 1:
        if pair_choice == 'outermost':
            methylation_leftmost = methylation_index[0]
            methylation_rightmost = methylation_index[-1]
            position_leftmost = read.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
            position_rightmost = read.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
            # If read is aligned to OB-strand then translate co-ordinate "ob_strand_offset" bases to the left so that it points to the C on the OT-strand of the methylation site.
            if read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
                position_leftmost -= ob_strand_offset
                position_rightmost -= ob_strand_offset
            # Skip readpair if methylation sites are incorrectly ordered and report a warning.
            # Else add the pair of methylation sites to the methylation_pairs instance.
            if position_leftmost >= position_rightmost:
                warning_msg = ' '.join(["Skipping single-end read", read.qname,  "as position_leftmost >= position_rightmost (Case A). Details: ", BAM.getrname(read.tid), str(position_leftmost), str(position_rightmost), read.opt('XM')[methylation_leftmost], read.opt('XM')[methylation_rightmost]])
                warnings.warn(warning_msg)
            else:
                # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                pair_id = ':'.join([BAM.getrname(read.tid), str(position_leftmost), str(position_rightmost)])
                # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                if not pair_id in methylation_pairs:
                    methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                    methylation_pairs[pair_id].increment_count(''.join([read.opt('XM')[methylation_leftmost], read.opt('XM')[methylation_rightmost]]), read, None)
                else:
                    methylation_pairs[pair_id].increment_count(''.join([read.opt('XM')[methylation_leftmost], read.opt('XM')[methylation_rightmost]]), read, None)
        elif pair_choice == 'all':
            for i in range(0, len(methylation_index)):
                if i < len(methylation_index):
                    j = i + 1
                    for k in range(j, len(methylation_index)):
                        methylation_leftmost = methylation_index[i]
                        methylation_rightmost = methylation_index[k]
                        position_leftmost = read.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                        position_rightmost = read.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                        # If read is aligned to OB-strand then translate co-ordinate "ob_strand_offset" bases to the left so that it points to the C on the OT-strand of the methylation site.
                        if read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
                            position_leftmost -= ob_strand_offset
                            position_rightmost -= ob_strand_offset
                        # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                        # Else add the pair of methylation sites to the methylation_pairs instance.
                        if position_leftmost >= position_rightmost:
                            warning_msg = ' '.join(["ERROR (Case A): Skipping single-end read",  read.qname,  "as position_leftmost >= position_rightmost. Details: ", BAM.getrname(read.tid), str(position_leftmost), str(position_rightmost), read.opt('XM')[methylation_leftmost], read.opt('XM')[methylation_rightmost]])
                            warnings.warn(warning_msg)
                        else:
                            # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                            pair_id = ':'.join([BAM.getrname(read.tid), str(position_leftmost), str(position_rightmost)])
                            # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                            if not pair_id in methylation_pairs:
                                methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                methylation_pairs[pair_id].increment_count(''.join([read.opt('XM')[methylation_leftmost], read.opt('XM')[methylation_rightmost]]), read, None)
                            else:
                                methylation_pairs[pair_id].increment_count(''.join([read.opt('XM')[methylation_leftmost], read.opt('XM')[methylation_rightmost]]), read, None)
    return methylation_pairs, n_methylation_sites

def extract_and_update_methylation_index_from_paired_end_reads(read_1, read_2, BAM, methylation_pairs, pair_choice):
    """Extracts pairs of methylation sites from a readpair and adds the comethylation states to the methylation_pairs object.
    
    Args:
        read_1: An AlignedRead instance corresponding to read_1 of the readpair.
        read_2: An AlignedRead instance corresponding to read_2 of the readpair.
        BAM: The Samfile instance corresponding to the sample. Required in order to extract chromosome names from read.
        methylation_pairs: A dictionary storing all observed pairs of methylation events and their WithinFragmentComethylationPair instance. An exmaple of a pair of methylation sites is a CpG-pair. 
        pair_choice: A string indicating how the pairs of methylation sites are to be constructed: "all" (all possible pairs) or "outermost" (the pair with the largest intra-pair distance). NB: "outermost" ensures each read is only used once in the within-fragment comethylation analysis.
    Returns:
        methylation_pairs: An updated version of methylation_pairs
        n_methylation_sites: The number of methylation sites extracted from the read.
    """
    # Identify methylation events in read, e.g. CpGs or CHHs. The methylation_pattern is specified by a command line argument (e.g. Z/z corresponds to CpG)
    methylation_index_1 = [m.start() for m in re.finditer(methylation_pattern, read_1.opt('XM'))]
    methylation_index_2 = [m.start() for m in re.finditer(methylation_pattern, read_2.opt('XM'))]
    n_methylation_sites = len(methylation_index_1) + len(methylation_index_2)
    # Ignore any start or end positions of read, as specified by command line arguments
    if args.ignoreStart > 0:
        methylation_index_1 = ignore_first_n_bases(read_1, methylation_index_1, args.ignoreStart)
        methylation_index_2 = ignore_first_n_bases(read_2, methylation_index_2, args.ignoreStart)
    if args.ignoreEnd > 0:
        methylation_index_1 = ignore_last_n_bases(read_1, methylation_index_1, args.ignoreEnd)
        methylation_index_2 = ignore_last_n_bases(read_2, methylation_index_2, args.ignoreEnd)
    # Ignore any positions with a base quality less than the args.minQual, as specified by command line arguments
    methylation_index_1 = ignore_low_quality_bases(read_1, methylation_index_1, args.minQual, phred_offset)
    methylation_index_2 = ignore_low_quality_bases(read_2, methylation_index_2, args.minQual, phred_offset)
    # Check for overlapping reads from a readpair.
    # If reads overlap check whether the overlapping sequence is identical
    # If the overlapping sequence is not identical report a warning and skip the readpair.
    n_overlap = read_1.alen + read_2.alen - abs(read_1.tlen)
    if n_overlap > 0:
        if is_overlapping_sequence_identical(read_1, read_2, n_overlap) or args.skipIdenticalOverlapCheck:
            methylation_index_1, methylation_index_2 = ignore_overlapping_sequence(read_1, read_2, methylation_index_1, methylation_index_2, n_overlap)
        else:
            warning_msg = ''.join(['Skipping readpair ', read.qname, ' as overlapping sequence is not identical'])
            warnings.warn(warning_msg)
            methylation_index_1 = []
            methylation_index_2 = []
    # Case 1: Readpair aligns to OT-strand
    if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        # Case A: > 0 CpGs in both reads of the readpair.
        if len(methylation_index_1) > 0 and len(methylation_index_2) > 0:
            if pair_choice == 'outermost':
                methylation_leftmost = methylation_index_1[0]
                methylation_rightmost = methylation_index_2[-1]
                position_leftmost = read_1.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                position_rightmost = read_2.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                # Else add the pair of methylation sites to the methylation_pairs instance.
                if position_leftmost >= position_rightmost:
                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 1A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                    warnings.warn(warning_msg)
                else:
                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                    if not pair_id in methylation_pairs:
                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                    else:
                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
            elif pair_choice == 'all':
                # First, create all pairs of methylation sites where each site is from read_1.
                if len(methylation_index_1) > 1:
                    for i in range(0, len(methylation_index_1)):
                        if i < len(methylation_index_1):
                            j = i + 1
                            for k in range(j, len(methylation_index_1)):
                                methylation_leftmost = methylation_index_1[i]
                                methylation_rightmost = methylation_index_1[k]
                                position_leftmost = read_1.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                                position_rightmost = read_1.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                                # Else add the pair of methylation sites to the methylation_pairs instance.
                                if position_leftmost >= position_rightmost: 
                                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 1A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                                    warnings.warn(warning_msg)
                                else:
                                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                    if not pair_id in methylation_pairs:
                                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                    else:
                                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                # Second, create all pairs of methylation sites where the leftmost event is from read_1 and the rightmost event is from read_2.
                for i in range(0, len(methylation_index_1)):
                    for j in range(0, len(methylation_index_2)):
                        methylation_leftmost = methylation_index_1[i]
                        methylation_rightmost = methylation_index_2[j]
                        position_leftmost = read_1.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                        position_rightmost = read_2.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                        # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                        # Else add the pair of methylation sites to the methylation_pairs instance.
                        if position_leftmost >= position_rightmost: 
                            warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 1A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                            warnings.warn(warning_msg)
                        else:
                            # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                            pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                             # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                            if not pair_id in methylation_pairs:
                                methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                            else:
                                methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                # Finally, create all pairs of methylation sites where both sites are from read_2
                if len(methylation_index_2) > 1:
                    for i in range(0, len(methylation_index_2)): 
                        if i < len(methylation_index_2):
                            j = i + 1
                            for k in range(j, len(methylation_index_2)):
                                methylation_leftmost = methylation_index_2[i]
                                methylation_rightmost = methylation_index_2[k]
                                position_leftmost = read_2.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                                position_rightmost = read_2.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                                # Else add the pair of methylation sites to the methylation_pairs instance.
                                if position_leftmost >= position_rightmost: 
                                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 1A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                                    warnings.warn(warning_msg)
                                else:
                                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                    if not pair_id in methylation_pairs:
                                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                    else:
                                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
        # CaseB: > 1 methylation site in read_1 but 0 methylation sites in read_2.
        elif len(methylation_index_1) > 1 and len(methylation_index_2) == 0:
            if pair_choice == 'outermost':
                methylation_leftmost = methylation_index_1[0]
                methylation_rightmost = methylation_index_1[-1]
                position_leftmost = read_1.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                position_rightmost = read_1.pos + methylation_rightmost +1 # +1 to transform from 0-based to 1-based co-ordinates
                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                # Else add the pair of methylation sites to the methylation_pairs instance.
                if position_leftmost >= position_rightmost:
                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 1B). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                    warnings.warn(warning_msg)
                else:
                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                    if not pair_id in methylation_pairs:
                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                    else:
                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
            elif pair_choice == 'all':
                for i in range(0, len(methylation_index_1)):
                    if i < len(methylation_index_1):
                        j = i + 1
                        for k in range(j, len(methylation_index_1)):
                            methylation_leftmost = methylation_index_1[i]
                            methylation_rightmost = methylation_index_1[k]
                            position_leftmost = read_1.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                            position_rightmost = read_1.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                            # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                            # Else add the pair of methylation sites to the methylation_pairs instance.
                            if position_leftmost >= position_rightmost: 
                                warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 1B). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                                warnings.warn(warning_msg)
                            else:
                                # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                if not pair_id in methylation_pairs:
                                    methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                    methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                else:
                                    methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
        # Case C: 0 methylation sites in read_1 but > 1 methylation site in read_2.
        elif len(methylation_index_1) == 0 and len(methylation_index_2) > 1:
            if pair_choice == 'outermost':
                methylation_leftmost = methylation_index_2[0]
                methylation_rightmost = methylation_index_2[-1]
                position_leftmost = read_2.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                position_rightmost = read_2.pos + methylation_rightmost +1 # +1 to transform from 0-based to 1-based co-ordinates
                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                # Else add the pair of methylation sites to the methylation_pairs instance.
                if position_leftmost >= position_rightmost:
                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 1C). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                    warnings.warn(warning_msg)
                else:
                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                    if not pair_id in methylation_pairs:
                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                    else:
                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
            elif pair_choice == 'all':
                for i in range(0, len(methylation_index_2)):
                    if i < len(methylation_index_2):
                        j = i + 1
                        for k in range(j, len(methylation_index_2)):
                            methylation_leftmost = methylation_index_2[i]
                            methylation_rightmost = methylation_index_2[k]
                            position_leftmost = read_2.pos + methylation_leftmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                            position_rightmost = read_2.pos + methylation_rightmost + 1 # +1 to transform from 0-based to 1-based co-ordinates
                            # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                            # Else add the pair of methylation sites to the methylation_pairs instance.
                            if position_leftmost >= position_rightmost:
                                warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2C). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                                warnings.warn(warning_msg)
                            else:
                                # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                if not pair_id in methylation_pairs:
                                    methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                    methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                else:
                                    methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                    
    # Case 2: Readpair aligns to OB-strand
    elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        # Case A: > 0 methylation site in both reads of the readpair.
        if len(methylation_index_1) > 0 and len(methylation_index_2) > 0:
            if pair_choice == 'outermost':
                methylation_leftmost = methylation_index_2[0]
                methylation_rightmost = methylation_index_1[-1]
                position_leftmost = read_2.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                position_rightmost = read_1.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                # Else add the pair of methylation sites to the methylation_pairs instance.
                if position_leftmost >= position_rightmost: 
                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                    warnings.warn(warning_msg)
                else:
                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                    if not pair_id in methylation_pairs:
                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                    else:
                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
            elif pair_choice == 'all':
                # First, create all pairs of methylation sites where each site is from read_1
                if len(methylation_index_1) > 1:
                    for i in range(0, len(methylation_index_1)):
                        if i < len(methylation_index_1):
                            j = i + 1
                            for k in range(j, len(methylation_index_1)):
                                methylation_leftmost = methylation_index_1[i]
                                methylation_rightmost = methylation_index_1[k]
                                position_leftmost = read_1.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                                position_rightmost = read_1.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                                # Else add the pair of methylation sites to the methylation_pairs instance.
                                if position_leftmost >= position_rightmost:
                                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                                    warnings.warn(warning_msg)
                                else:
                                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                    if not pair_id in methylation_pairs:
                                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                    else:
                                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                # Second, create all pairs of methylation sites where the leftmost event is from read_2 and the rightmost event is from read_1.
                for i in range(0, len(methylation_index_2)):
                    for j in range(0, len(methylation_index_1)):
                        methylation_leftmost = methylation_index_2[i]
                        methylation_rightmost = methylation_index_1[j]
                        position_leftmost = read_2.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                        position_rightmost = read_1.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                        # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                        # Else add the pair of methylation sites to the methylation_pairs instance.
                        if position_leftmost >= position_rightmost: 
                            warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                            warnings.warn(warning_msg)
                        else:
                            # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                            pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                            # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                            if not pair_id in methylation_pairs:
                                methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                            else:
                                methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                 # Finally, create all pairs of methylation sites where both sites are from read_2
                if len(methylation_index_2) > 1:
                    for i in range(0, len(methylation_index_2)): 
                        if i < len(methylation_index_2):
                            j = i + 1
                            for k in range(j, len(methylation_index_2)):
                                methylation_leftmost = methylation_index_2[i]
                                methylation_rightmost = methylation_index_2[k]
                                position_leftmost = read_2.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                                position_rightmost = read_2.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                                # Else add the pair of methylation sites to the methylation_pairs instance.
                                if position_leftmost >= position_rightmost: 
                                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2A). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                                    warnings.warn(warning_msg)
                                else:
                                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                    if not pair_id in methylation_pairs:
                                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                    else:
                                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
        # CaseB: > 1 methylation site in read_1 but 0 methylation sites in read_2.
        elif len(methylation_index_1) > 1 and len(methylation_index_2) == 0:
            if pair_choice == 'outermost':
                methylation_leftmost = methylation_index_1[0]
                methylation_rightmost = methylation_index_1[-1]
                position_leftmost = read_1.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                position_rightmost = read_1.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                # Else add the pair of methylation sites to the methylation_pairs instance.
                if position_leftmost >= position_rightmost:
                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2B). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                    warnings.warn(warning_msg)
                else:
                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                    if not pair_id in methylation_pairs:
                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                    else:
                        methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
            elif pair_choice == 'all':
                for i in range(0, len(methylation_index_1)):
                    if i < len(methylation_index_1):
                        j = i + 1
                        for k in range(j, len(methylation_index_1)):
                            methylation_leftmost = methylation_index_1[i]
                            methylation_rightmost = methylation_index_1[k]
                            position_leftmost = read_1.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                            position_rightmost = read_1.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                            # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                            # Else add the pair of methylation sites to the methylation_pairs instance.
                            if position_leftmost >= position_rightmost:
                                warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2B). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]])
                                warnings.warn(warning_msg)
                            else:
                                # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                if not pair_id in methylation_pairs:
                                    methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                    methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                else:
                                    methylation_pairs[pair_id].increment_count(''.join([read_1.opt('XM')[methylation_leftmost], read_1.opt('XM')[methylation_rightmost]]), read_1, read_2)
        # Case C: 0 methylation sites in read_1 but > 1 methylation site in read_2.
        elif len(methylation_index_1) == 0 and len(methylation_index_2) > 1:
            if pair_choice == 'outermost':
                methylation_leftmost = methylation_index_2[0]
                methylation_rightmost = methylation_index_2[-1]
                position_leftmost = read_2.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                position_rightmost = read_2.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                # Else add the pair of methylation sites to the methylation_pairs instance.
                if position_leftmost >= position_rightmost:
                    warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2C). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                    warnings.warn(warning_msg)
                else:
                    # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                    pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                    # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                    if not pair_id in methylation_pairs:
                        methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                    else:
                        methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
            elif pair_choice == 'all':
                for i in range(0, len(methylation_index_2)):
                    if i < len(methylation_index_2):
                        j = i + 1
                        for k in range(j, len(methylation_index_2)):
                            methylation_leftmost = methylation_index_2[i]
                            methylation_rightmost = methylation_index_2[k]
                            position_leftmost = read_2.pos + methylation_leftmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                            position_rightmost = read_2.pos + methylation_rightmost + 1 - ob_strand_offset # +1 to transform from 0-based to 1-based co-ordinates, -ob_strand_offset to point to C on OT-strand for the methylation site.
                            # Skip readpair if methylation sites are incorrectly ordered and report a warning.
                            # Else add the pair of methylation sites to the methylation_pairs instance.
                            if position_leftmost >= position_rightmost:
                                warning_msg = ' '.join(["Skipping readpair",  read_1.qname,  "as position_leftmost >= position_rightmost (Case 2C). Details: ", BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost), read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]])
                                warnings.warn(warning_msg)
                            else:
                                # Create a unique ID for each pair of methylation sites (of form "chromosome:position_leftmost:position_rightmost")
                                pair_id = ':'.join([BAM.getrname(read_1.tid), str(position_leftmost), str(position_rightmost)])
                                # Check whether pair has already been observed. If not, create a WithinFragmentMethylationPair instance for it and increment its count.
                                if not pair_id in methylation_pairs:
                                    methylation_pairs[pair_id] = WithinFragmentComethylationPair(BAM.getrname(read_1.tid), create_chromosome_index(BAM.getrname(read.tid)), position_leftmost, position_rightmost, args.methylationType)
                                    methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
                                else:
                                    methylation_pairs[pair_id].increment_count(''.join([read_2.opt('XM')[methylation_leftmost], read_2.opt('XM')[methylation_rightmost]]), read_1, read_2)
    return methylation_pairs, n_methylation_sites
                                    

# tab_writer writes a tab-separated output file to the filehandle WF
tab_writer = csv.writer(WF, delimiter='\t', quotechar=' ', quoting=csv.QUOTE_MINIMAL)

def write_methylation_pairs_to_file(methylation_pairs):
    """Write the methylation_pairs instance to a tab-separated file. The pairs are ordered by chromosome and genomic co-ordinates.
    
    Args:
        methylation_pairs: A dictionary storing all observed pairs of methylation events and their WithinFragmentComethylationPair instance. An exmaple of a pair of methylation sites is a CpG-pair. 
    """
    # Create the header row
    header = ['chr', 'pos1', 'pos2']
    example_row = WithinFragmentComethylationPair('chr1', 1, 1, 2, 'CG').counts
    for key in sorted(example_row.iterkeys()):
        header.append(key)
    # Write the header to file
    tab_writer.writerow(header)
    # Write each pair of methylation sites to file using a triple-nested for loop
    # (1) Loop over chromosomes by increasing chromosome_index order
    # (2) Loop over position_1 by increasing order
    # (3) Loop over position_2 by increasing order
    for pair in sorted(methylation_pairs.values(), key = attrgetter('chromosome_index', 'position_1', 'position_2')):
        ordered_pair_counts = []
        for i in sorted(pair.counts.iterkeys()):
            ordered_pair_counts.append(pair.counts[i])
        row = [pair.chromosome, pair.position_1, pair.position_2] + ordered_pair_counts
        tab_writer.writerow(row)
    
#############################################################################################################################################################################################
### Variable initialisations ###
#############################################################################################################################################################################################
# Set the Phred quality score offset
if args.phred64:
    phred_offset = 64
else:
    phred_offset = 33

# Check key --pairChoice variable is validly set
if args.pairChoice != 'all' and args.pairChoice != 'outermost':
    sys.exit('ERROR: --pairChoice must be one of \'all\' or \'outermost\'')

# Set the methylation type to be used in the analysis
if args.methylationType == 'CG':
    methylation_pattern = re.compile(r'[Zz]')
    ob_strand_offset = 1
    MM = 'ZZ'
    MU = 'Zz'
    UM = 'zZ'
    UU = 'zz'
elif args.methylationType == 'CHG':
    methylation_pattern = re.compile(r'[Xx]')
    ob_strand_offset = 2
    MM = 'XX'
    MU = 'Xx'
    UM = 'xX'
    UU = 'xx'
elif args.methylationType == 'CHH':
    methylation_pattern = re.compile(r'[Hh]')
    ob_strand_offset = 0
    MM = 'HH'
    MU = 'Hh'
    UM = 'hH'
    UU = 'hh'
    sys.exit('Sorry, CHH-methylation is not yet implemented.')
else:
    sys.exit('--methylationType must be one of \'CG\' or \'CHG\'')
    
n_fragment = 0 # The number of DNA fragments. One single-end read contributes one to the count and each half of a readpair contributes half a count.
max_n_methylation_sites = 50
n_methylation_sites = [0] * max_n_methylation_sites
methylation_pairs = {} # Dictionary of pairs of methylation sites with keys of form chromosome:position_1:position_2 and values corresponding to a WithinFragmentComethylationPair instance

#############################################################################################################################################################################################
### The main program. Loops over the BAM file line-by-line (i.e. alignedRead-by-alignedRead) and extracts the XM information for each read or read-pair. ###
#############################################################################################################################################################################################

# Print key variable names and command line parameter options to STDOUT
print 'Input file =', BAM.filename
print 'Output file =', WF.name
if args.ignoreDuplicates:
    print 'Ignoring reads marked as PCR duplicates'
print 'Assuming quality scores are Phred', phred_offset
print 'Ignoring', args.ignoreStart, 'bp from start of each read'
print 'Ignoring', args.ignoreEnd, 'bp from end of each read'
print 'Ignoring methylation calls with base-quality less than', args.minQual
print 'Creating', args.pairChoice, 'pairs of methylation sites'
print 'Analysing', args.methylationType, 'methylation events'
if args.skipIdenticalOverlapCheck:
    print 'Not checking overlapping readpairs for whether the overlapping sequence is identical'

# Loop over the BAM
for read in BAM:
    # Skip duplicates reads if command line parameter --ignoreDuplicates is set
    if args.ignoreDuplicates and read.is_duplicate:
        if not read.is_paired:
            n_fragment += 1
        else:
            n_fragment += 0.5 
        continue
    elif read.is_paired and not read.is_proper_pair:
        warning_msg = ''.join(['Skipping read ', read.qname, ' as it is part of an improper pair.'])
        warnings.warn(warning_msg)
        n_fragment += 0.5
        continue
    else:
        if read.is_proper_pair and read.is_read1:
            read_1 = read
            continue
        elif read.is_proper_pair and read.is_read2: 
            read_2 = read
            n_fragment += 1
            # Check that read_1 and read_2 are aligned to the same chromosome and have identical read-names.
            # If not, skip the read-pair.
            if read_1.tid == read_2.tid and read_1.qname == read_2.qname:
                methylation_pairs, n_methylation_sites_in_fragment = extract_and_update_methylation_index_from_paired_end_reads(read_1, read_2, BAM, methylation_pairs, args.pairChoice)
                n_methylation_sites[n_methylation_sites_in_fragment] += 1                
            elif read_1.tid != read_2.tid:
                warning_msg = ''.join(['Skipping readpair', read_1.qname, ' as reads aligned to different chromosomes (', BAM.getrname(read_1.tid), ' and ', BAM.getrname(read_2.tid), ')'])
                warnings.warn(warning_msg)
                continue
            elif read_1.qname != read_2.qname:
                exit_msg = "ERROR: The name of read_1 is not identical to to that of read_2 for readpair ", read_1.qname, read_2.qname, "\nPlease sort your paired-end BAM file in query-name-order with Picard's SortSam function."
                sys.exit(exit_msg)
        elif not read.is_paired:
            n_fragment += 1
            methylation_pairs, n_methylation_sites_in_fragment = extract_and_update_methylation_index_from_single_end_read(read, BAM, methylation_pairs, args.pairChoice)
            n_methylation_sites[n_methylation_sites_in_fragment] += 1
        else:
            print "Read is neither a single-end read nor part of a paired-end read. Check the SAM flag values are correctly set for read:", read.qname
            continue

# Write results to disk
print 'Writing output to', WF.name, '...'
write_methylation_pairs_to_file(methylation_pairs)
BAM.close()
WF.close()

print 'Number of DNA fragments in file:', int(n_fragment)
print 'Number of DNA fragments informative for within-fragment comethylation', sum(n_methylation_sites[2:]), '(', round(sum(n_methylation_sites[2:]) / float(n_fragment) * 100, 1), '%)'
print 'Histogram of number of', args.methylationType, 'methylation sites per DNA fragment'
print 'n\tcount'
for i in range(len(n_methylation_sites)):
    '{i}, {j}'.format(i = i, j = n_methylation_sites[i])
##############################################################################################################################################################################################
