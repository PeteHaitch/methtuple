#!/usr/bin/python
import re
from numpy import array
import argparse
import sys
import csv
import pysam
import warnings

## This program is Copyright (C) 2012, Peter Hickey (hickey@wehi.edu.au)

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.

### Program description ###
############################################################################################################################################################################################
# Extract within-fragment co-methylation measurements at CpGs for the aligned reads from a BS-Seq experiment.
# SAM/BAM must be generated by Bismark. Other aligners will be supported in future releases. The SAM/BAM file must comply with the SAM spec (v1.4). The Bismark SAM file does not comply with these standards and must be pre-processed with correct_Bismark.py. The reason for this is that the Bismark SAM file does not correctly encode the orientation of read-pairs in the SAM flag field.
# The SAM/BAM can contain single-end reads, paired-end reads or a combination of the two types. The type of sequencing performed is determined by checking whether the 0x01 flag bit is set ("template being sequenced has multiple fragments"). SAM/BAM files containing paired-end reads must be sorted by query-name using Picard's SortSam function.
# CpGs are identified by examining the XM-tag of each read. The XM-tag is reference-based, so only reference Cpgs are examined. This means that sample-specific CpGs are ignored and reference-specific CpGs, which may not be CpGs in the sample of interest, are also examined.
# This program brings together the functionality of SAM2MS.py and QS_PE_SAM2MS.py and summarise_MS.py.
# There are two types of comethylation: (1) Within-fragment co-methylation (WF), which is the dependence of methylation states along a DNA read/fragment/chromosome that contains multiple Cpgs; and (2) correlation of aggregate methylation values (AM). Aggregate methylation values are based on the pileup of reads at each CpG and include beta = M/(U+M) and gamma = log((M + eps)/(U + eps)), where M = the number of methylated Cs, U = the number of unmethylated Cs and esp is a small number to ensure numerical stability of gamma, typically esp = 0.5.
# co-methylation extracts the necessary information to analyse (1), it does not perform the statistical analysis. A sister program, aggregate_methylation.py, extracts the necessary information to analyse (2).
# If the reads from a read-pair overlap then, provided the overlapping sequence is identical, we trim the lower quality read until no overlap remains. If the overlapping sequence is not identical then we ignore the read-pair. This behaviour may be altered in future releases.
# WARNING
############################################################################################################################################################################################

### Description of sample.wf ###
############################################################################################################################################################################################
# Each line corresponds to a CpG-pair and includes a count of the number of methylated Cs (M), unmethylated Cs (U) and other bases (other) for that CpG.
# CpG-pairs can be created in several ways, see comethylation.py --help for details. Each pair is defined as (CpG1, CpG2), where CpG1 is the leftmost CpG in the pair and CpG2 is the rightmost CpG in the pair (with reference to Watson-strand coordinates).
# The data for each CpG-pair are stratified by which strand the reads aligned to: Original Top (OT) aka Watson-strand aka forward-strand aka "+"-strand; Original Bottom (OB) aka Crick-strand aka reverse-strand aka "-"-strand and combined across strands.
# The strand information is encoded as a subscript, e.g. MM_OT is the count of reads informative for the OT-strand that are methylated at both CpGs in the CpG-pair, MU_OB is the count of reads informative for the OB-strand that are methylated at CpG1 and unmethylated at CpG2, UU (no subscript) is the count of reads, combined across strands, that are unmethylated at both CpGs in the CpG-pair.
############################################################################################################################################################################################

### Explanation of XM-tag (methylation string) ###
############################################################################################################################################################################################
# . for bases not involving cytosines                       
# X for methylated C in CHG context (was protected)         
# x for not methylated C in CHG context (was converted)     
# H for methylated C in CHH context (was protected)         
# h for not methylated C in CHH context (was converted)     
# Z for methylated C in CpG context (was protected)         
# z for not methylated C in CpG context (was converted)
# U for methylated C in "unknown" context, e.g. CNN-context, (was protected). Non-standard Bismark XM-tag values; unique to output of XM_tag.py.
# u for not methylated C in "unknown"-context, e.g. CNN-context, (was converted). Non-standard Bismark XM-tag values; unique to output of XM_tag.py.
############################################################################################################################################################################################

### TODOs ###
############################################################################################################################################################################################
# TODO: Improve method for ignoring bases at 5' or 3' end of reads. Specifically, it might be good to have option that, for example, trims the last 5 bases of reads if the read is longer than 75nt otherwise the read is left untrimmed.
# TODO: Remove 'orientation' from code; instead use XG-tag.
# TODO: Extend to 4-strand protocol. This will require the BAM file to have both the XG-tag and the XR-tag specified by Bismark. See "Paired_end_read_orientation.docx" on Google Drive.
# TODO: read.is_paired checks if the read is paired in-sequencing. Problems may arise if the mate of a read that is paired in-sequencing is not present in the SAM/BAM (e.g. if only one read of the read-pair is mapped).
# TODO: Insert program description in arg.parse
# TODO: Add option to ignore a different number of bases from the ends of reads depending on whether it is read_1 or read_2
# TODO: Learn the difference between read.alen, read.qlen and read.rlen; decide which is most appropriate for this script.
# TODO: Include all WARNINGS in program description
############################################################################################################################################################################################

### Command line parser ###
############################################################################################################################################################################################
parser = argparse.ArgumentParser(description='Extract within-fragment co-methylation measurements at CpGs from the aligned reads of a BS-Seq experiment. WARNING: Currently only works for the two-strand BS-seq protocol for reads without soft-clipping or indels and requires Bismark-style BAM files including XG-, XR- and XM-tags.')
parser.add_argument('BAM', metavar = 'BAM',
                    help='The path to the SAM/BAM file')
parser.add_argument('sampleName',
                    metavar = 'sampleName',
                    help='The name of the sample. All output files will have this prefix.')
parser.add_argument('--ignoreDuplicates',
                    action='store_true',
                    help='Ignore reads that have been flagged as PCR duplicates by Picard\'s MarkDuplicates function')
parser.add_argument('--ignoreStart', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Ignore first <int> bases from start of reads, where start is the first sequenced base not necessarily the leftmost aligned base (default: 0). WARNING: Parameter value not sanity checked by program.')
parser.add_argument('--ignoreEnd', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Ignore last <int> bases from end of reads, where end is the last sequenced base not necessarily the rightmost aligned base (default: 0). WARNING: Parameter value not sanity checked by program.')
parser.add_argument('--minQual', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Minimum base-quality (default: 0). Any base with a lower base-quality is ignored.')
parser.add_argument('--pairChoice',
                    metavar = '<string>',
                    default="outermost",
                    help='Method for constructing CpG-pairs: outermost or all (default: outermost)')
parser.add_argument('--phred64',
                    action='store_true',
                    help='Quality scores are encoded as Phred64 (default: Phred33)')
parser.add_argument('--version',
                    action='version', version='%(prog)s 2.0')

args = parser.parse_args()
############################################################################################################################################################################################

### Open SAM/BAM file and output files ###
############################################################################################################################################################################################
BAM = pysam.Samfile(args.BAM)
WF = open(".".join([args.sampleName, "wf"]), "w")
############################################################################################################################################################################################

### Function definitions ###
#############################################################################################################################################################################################
def ignore_first_n_cpgs(read, cpg_index, n):
    """Ignore CpGs occuring in the first n bases of a read that contribtue to a read's cpg_index.

    Args:
        read: A pysam.AlignedRead instance.
        cpg_index: A list of zero-based indices.  Each index corresponds to the leftmost aligned position of a CpG in a read. For example:

        [0, 5]

        Corresponds to a read with a CpG at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.

    Returns:
        A list of zero-based indices (possibly empty).  Each index corresponds to the leftmost aligned position of a CpG in a read. For example:

        [0, 5]

        corresponds to a read with a CpG at the first and sixth positions of the read.
    """
    ignore_these_cpgs = []
    # Single-end reads
    if not read.is_paired:
        # Read aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i < n:
                    ignore_these_cpgs.append(i)
        # Read aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i >= (read.alen - n):
                    ignore_these_cpgs.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            cpg_index = []
    # Paired-end reads: read_1
    elif read.is_paired and read.is_read_1:
        # read_1 aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i < n:
                    ignore_these_cpgs.append(i)
        # read_1 aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i >= (read.alen - n):
                    ignore_these_cpgs.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            cpg_index = []
    # Paired-end reads: read_2
    elif read.is_paired and read.is_read_2:
        # read_2 aligned to OT-strand <------|
        if read.opt('XG') == 'CT' and read.opt('XR') == 'GA':
            for i in cpg_index:
                if i >= (read.alen - n):
                    ignore_these_cpgs.append(i)
        # read_2 aligned to OB-strand |------>
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'GA':
            for i in cpg_index:
                if i < n:
                    ignore_these_cpgs.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            cpg_index = []
    # Skipping read because it does not have necessary information to infer whether read is paired or whether the read is read_1 or read_2 of the pair.
    else:
        warning_msg = ''.join(['Skipping read ', read.qname, '. Missing 0x01, 0x40 or 0x80 FLAG bit (paired-read FLAG information)'])
        warnings.warn(warning_msg)
        cpg_index = []
    return [x for x in cpg_index if x not in ignore_these_cpgs]

def ignore_last_n_cpgs(read, cpg_index, n):
    """Ignore CpGs occuring in the last n bases of a read that contribute to a read's cpg_index.

    Args:
        read: A pysam.AlignedRead instance.
        cpg_index: A list of zero-based indices.  Each index corresponds to the leftmost aligned position of a CpG in a read. For example:

        [0, 5]

        corresponds to a read with a CpG at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.

    Returns:
        A list of zero-based indices (possibly empty).  Each index corresponds to the leftmost aligned position of a CpG in a read. For example:

        [0, 5]

        Corresponds to a read with a CpG at the first and sixth positions of the read.
    """
    ignore_these_cpgs = []
    # Single-end reads
    if not read.is_paired:
        # Read aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i >= (read.alen - n):
                    ignore_these_cpgs.append(i)
        # Read aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i < n:
                    ignore_these_cpgs.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            cpg_index = []
    # Paired-end reads: read_1
    elif read.is_paired and read.is_read_1:
        # read_1 aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i >= (read.alen - n):
                    ignore_these_cpgs.append(i)
        # read_1 aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in cpg_index:
                if i < n:
                    ignore_these_cpgs.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            cpg_index = []
    # Paired-end reads: read_2
    elif read.is_paired and read.is_read_2:
        # read_2 aligned to OT-strand <------|
        if read.opt('XG') == 'CT' and read.opt('XR') == 'GA':
            for i in cpg_index:
                if i < n:
                    ignore_these_cpgs.append(i)
        # read_2 aligned to OB-strand |------>
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'GA':
            for i in cpg_index:
                if i  >= (read.alen - n):
                    ignore_these_cpgs.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            cpg_index = []
    # Skipping read because it does not have necessary information to infer whether read is paired or whether the read is read_1 or read_2 of the pair.
    else:
        warning_msg = ''.join(['Skipping read ', read.qname, '. Missing 0x01, 0x40 or 0x80 FLAG bit (paired-read FLAG information)'])
        warnings.warn(warning_msg)
        cpg_index = []
    return [x for x in cpg_index if x not in ignore_these_cpgs]
        
def ignore_low_quality_bases(read, cpg_index, min_qual, phred_offset):
    """Ignore low quality bases of a read that contribute to a read's cpg_index.

    Args:
        read: A pysam.AlignedRead instance.
        cpg_index: A list of zero-based indices.  Each index corresponds to the leftmost aligned position of a CpG in a read. For example:

        [0, 5]

        Corresponds to a read with a CpG at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.
        min_qual: The minimum base qualit (integer). All bases with quality < min_qual are excluded from the returned cpg_index object.
        phred_offset: The Phred offset of the data - 33 or 64.

    Returns:
        A list of zero-based indices (possibly empty).  Each index corresponds to the leftmost aligned position of a CpG in a read. For example:

        [0, 5]

        Corresponds to a read with a CpG at the first and sixth positions of the read.
    
    """
    ignore_these_cpgs = []
    for i in cpg_index:
        if (ord(read.qual[i]) - phred_offset) < min_qual:
            ignore_these_cpgs.append(i)
    return [x for x in cpg_index if x not in ignore_these_cpgs]

def is_overlapping_sequence_identical(read_1, read_2, n_overlap):
    """Check whether the overlapping sequence of read_1 and read_2 is identical.

    Args:
        read_1: A pysam.AlignedRead instance with read.is_read_1 == true. Must be paired with read_2.
        read_2: A pysam.AlignedRead instance with read.is_read_2 == true. Must be paired with read_1.
        n_overlap: The number of bases in the overlap of read_1 and read_2 (must be > 0)

    Returns:
        True if the overlapping sequence is identical, False otherwise (NB: this means that readpairs that trigger the warning for having mis-specified XG- or XR-tags will also return 'False').
    """
    # Readpair aligns to OT-strand
    if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_1 = read_1.seq[-n_overlap:]
        overlap_2 = read_2.seq[:n_overlap]
    # Readpair aligns to OB-strand
    elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_1 = read_1.seq[:n_overlap]
        overlap_2 = read_2.seq[-n_overlap]
    else:
        warning_msg = ''.join(['XG-tags or XR-tags for readpair ', read.qname, ' are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
        warnings.warn(warning_msg)
        overlap_1 = True
        overlap_2 = False
    return overlap_1 == overlap_2

def ignore_overlapping_sequence(read_1, read_2, cpg_index_1, cpg_index_2, n_overlap):
    """Ignore the overlapping sequence of read_1 and read_2 from the read with the lower (sum) base qualities in the overlapping region.
       If base qualities are identical then (arbitrarily) ignore the overlapping bases from read_2.

    Args:
        read_1: A pysam.AlignedRead instance with read.is_read_1 == true. Must be paired with read_2.
        read_2: A pysam.AlignedRead instance with read.is_read_2 == true. Must be paired with read_1.
        cpg_index_1: A list of zero-based indices.  Each index corresponds to the leftmost aligned position of a CpG in read_1. For example:

        [0, 5]

        corresponds to read_1 with a CpG at the first and sixth positions of the read.
        cpg_index_2: A list of zero-based indices.  Each index corresponds to the leftmost aligned position of a CpG in read_2. For example:

        [0, 5]

        corresponds to read_2 with a CpG at the first and sixth positions of the read.
        n_overlap: The number of bases in the overlap (must be > 0).

    Returns:
        cpg_index_1, cpg_index_2: The cpg_indexes corresponding to read_1 and read_2 respectively, post-overlap-removal.
    """
    ignore_these_cpgs = []
    # Readpair aligns to OT-strand
    if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_quals_1 = sum([ord(x) for x in read_1.qual[-n_overlap:]])
        overlap_quals_2 = sum([ord(x) for x in read_2.qual[-n_overlap:]])
        if overlap_quals_1 >= overlap_quals_2:
            for i in cpg_index_2:
                if i < n_overlap:
                    ignore_these_cpgs.append(i)
                    cpg_index_2 = [x for x in cpg_index_2 if x not in ignore_these_cpgs]
        else:
            for i in cpg_index_1:
                if i >= (read.alen - n_overlap):
                    ignore_these_cpgs.append(i)
                    cpg_index_1 = [x for x in cpg_index_1 if x not in ignore_these_cpgs]
    # Readpair aligns to OB-strand
    elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_quals_1 = sum([ord(x) for x in read_1.qual[:n_overlap]])
        overlap_quals_2 = sum([ord(x) for x in read_2.qual[-n_overlap:]])
        if overlap_quals_1 >= overlap_quals_2:
            for i in cpg_index_2:
                if i >= (read_2.alen - n_overlap):
                    ignore_these_cpgs.append(i)
                    cpg_index_2 = [x for x in cpg_index_2 if x not in ignore_these_cpgs]
        else:
            for i in cpg_index_1:
                if i < n_overlap:
                    ignore_these_cpgs.append(i)
                    cpg_index_1 = [x for x in cpg_index_1 if x not in ignore_these_cpgs]
    else:
        warning_msg = ''.join(['Skipping readpair ', read.qname, ' as XG-tags or XR-tags are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
        warnings.warn(warning_msg)
        cpg_index_1 = []
        cpg_index_2 = []
    return cpg_index_1, cpg_index_2

## Create a dictionary of methylation-states for a CpG-pair
def makeWFCount():
    return  {'MM': 0, 'MU': 0, 'UM': 0, 'UU': 0, 'MM_OT': 0, 'MU_OT': 0, 'UM_OT': 0, 'UU_OT': 0, 'MM_OB': 0, 'MU_OB': 0, 'UM_OB': 0, 'UU_OB': 0}

## Increment the counts in an makeWFCount() object based on the new information from an element of fragment_MS, the output of SAM2MS_SE() or SAM2MS_PE().
def incrementWFCount(CpG_pair, thisPair, readname): # CpG_pair is the current count of comethylation (a makeWFCount object). thisPair is an element of the list-of-lists fragment_MS, e.g. fragment_MS[0]
    ms = ''.join(thisPair[3:5]) # The CpG methylation state - ZZ, Zz, zZ or zz - for that CpG-pair from that read
    strand = thisPair[5]
    if ms == 'ZZ':
        CpG_pair['MM'] += 1
        if strand == 'OT':
            CpG_pair['MM_OT'] += 1
        elif strand == 'OB':
            CpG_pair['MM_OB'] +=1
        return CpG_pair
    elif ms == 'Zz':
        CpG_pair['MU'] += 1
        if strand == 'OT':
            CpG_pair['MU_OT'] += 1
        elif strand == 'OB':
            CpG_pair['MU_OB'] +=1
        return CpG_pair
    elif ms == 'zZ':
        CpG_pair['UM'] += 1
        if strand == 'OT':
            CpG_pair['UM_OT'] += 1
        elif strand == 'OB':
            CpG_pair['UM_OB'] +=1
        return CpG_pair
    elif ms == 'zz':
        CpG_pair['UU'] += 1
        if strand == 'OT':
            CpG_pair['UU_OT'] += 1
        elif strand == 'OB':
            CpG_pair['UU_OB'] +=1
        return CpG_pair
    else:
        exit_msg = ''.join(['Error: Invalid methylation string (',  thisPair, ') for read:', readname])
        sys.exit(exit_msg)
 
## SAM2MS_SE extracts, summarises and returns the methylation string (MS) information for a read mapped as single-end data
## The return value is a list-of-lists, with length equal to the number of pairs extracted from the read. Thus a result value with length = 0 means there were no CpGs pairs extracted from that read (or there was an error with the pairs extracted), a result value with length = 0 means one CpG-pair, a result value with length = 2 means two CpG-pairs, etc.
## NB: strand == 'OT' ('OB') is the same as orientation == '+' ('-') for the two-strand protocol
def SAM2MS_SE(read):
    chrom = BAM.getrname(read.tid)
    start = read.pos + 1 # read.pos is 0-based in accordance with BAM file specificiations, regardless of whether the input file is SAM or BAM. I convert this to a 1-based position.
    strand = getStrand(read)
    # Identify CpGs in read
    CpG_index = [m.start() for m in re.finditer(CpG_pattern, read.opt('XM'))]
     # Remove 'ignore3' and 'ignore5' CpG-methylation calls from consideration 
    if args.ignore3 > 0:
        CpG_index = ignore3(args.ignore3, CpG_index, read.rlen, read.opt('XG'), read.qname)
    if args.ignore5 > 0:
        CpG_index = ignore5(args.ignore5, CpG_index, read.rlen, read.opt('XG'), read.qname)
    # Remove low quality CpG-methylation calls from consideration
    CpG_index = removeLowQualMS(CpG_index, read.qual, minQual, PhredOffset)
    # Case A: > 1 CpG in read
    if len(CpG_index) > 1:
        if pairChoice == 'outermost':
            output = []
            CpGL = CpG_index[0] # Leftmost CpG in read
            CpGR = CpG_index[-1] # Rightmost CpG in read
            positionL = start + CpGL
            positionR = start + CpGR
            if strand == 'OB': # If read is aligned to OB-strand then translate co-ordinate 1bp to the left so that it points to the C in the CpG on the OT-strand
                positionL -= 1
                positionR -= 1
            output.append([chrom, positionL, positionR, read.opt('XM')[CpGL], read.opt('XM')[CpGR], strand]) # Output is left-to-right, thus read_1XM appears before read_2XM for OT read-pairs.
            if positionL > positionR:
                print "ERROR: Case1A posL > posR for single-end read ", read_1.qname," with output ", [chrom, positionL, positionR, read.opt('XM')[CpGL], read.opt('XM')[CpGR], strand]
        elif pairChoice == 'all':
            output = []
            for i in range(0, len(CpG_index)):
                if i < len(CpG_index):
                    j = i + 1
                    for k in range(j, len(CpG_index)):
                        CpGL = CpG_index[i]
                        CpGR = CpG_index[k]
                        positionL = start + CpGL
                        positionR = start + CpGR
                        if strand == 'OB': # Translate co-ordinate 1bp to the left so that it points to the C in the CpG on the OT-strand
                            positionL -= 1
                            positionR -= 1
                        output.append([chrom, positionL, positionR, read.opt('XM')[CpGL], read.opt('XM')[CpGR], strand])
    else: # Less than 2 CpGs in read, therefore no within-fragment comethylation measurement for this read.
        output = []
    return output

## SAM2MS_PE extracts, summarises and returns the methylation string (MS) information for a read-pair mapped as paired-end data.
def SAM2MS_PE(read_1, read_2):
    chrom = BAM.getrname(read_1.tid)
    start1 = read_1.pos + 1 # read_1.pos is 0-based in accordance with BAM file specificiations, regardless of whether the input file is SAM or BAM. I convert this to a 1-based position.
    start2 = read_2.pos + 1 # read_2.pos is 0-based in accordance with BAM file specificiations, regardless of whether the input file is SAM or BAM. I convert this to a 1-based position.
    strand = getStrand(read_1, read_2) # strand = OT or OB, the strand for which the read-pair is informative.
    # Store the XM tag for each read. Tags are stored as a Python list of 2-tuples [("TAG_NAME", "TAG_VALUE"), ...]. This assumes there is one, and one only, XM tag per read
    read_1XM = [tag[1] for tag in read_1.tags if tag[0] == 'XM'][0] 
    read_2XM = [tag[1] for tag in read_2.tags if tag[0] == 'XM'][0]
    # Identify CpGs in read_1 and read_2
    CpG_index1 = [m.start() for m in re.finditer(CpG_pattern, read_1XM)]
    CpG_index2 = [m.start() for m in re.finditer(CpG_pattern, read_2XM)]
    # Orientation of read-pair
    if not read_1.is_reverse and read_2.is_reverse:
        orientation = '+/-'
    elif read_1.is_reverse and not read_2.is_reverse:
        orientation = '-/+'
    else:
        print 'ERROR: Unexpected orientation of read-pair', read_1.qname
        output = []
        return output
    # Check for overlapping reads from a read-pair. If reads overlap, check that the overlapping sequenced is identical. If the overlapping sequence is identical, ignore the methylation calls in the overlapping region from the lower quality read. If the overlapping sequence is not identical, report a warning and skip the read-pair.
    n_overlap = read_1.rlen + read_2.rlen - abs(read_1.tlen)
    if n_overlap > 0 : # If True, then the reads overlap and we need to ignore any CpG-methylation calls in the overlap from one of the reads using removeOverlap()
        identicalOverlap, overlap1, overlap2 = overlappingSeqIdentical(read_1.seq, read_2.seq, n_overlap, orientation)
        if identicalOverlap:
            #print 'Identical overlap. Overlap 1 =', overlap1, 'Overlap2 =', overlap2 
            CpG_index1, CpG_index2 = removeOverlap(n_overlap, orientation, CpG_index1, CpG_index2, read_1.qual, read_2.qual) # Remove from consideration the methylation calls in the overlapping region from the lower quality read 
        else:
            #print 'WARNING: Skipping read-pair due to non-identical overlapping sequence', read_1.qname
            #print 'Overlap1 =', overlap1, 'Overlap2 =', overlap2
            output = []
            return output
    # Remove low quality CpG-methylation calls from consideration
    CpG_index1 = removeLowQualMS(CpG_index1, read_1.qual, minQual, PhredOffset) 
    CpG_index2 = removeLowQualMS(CpG_index2, read_2.qual, minQual, PhredOffset)
    # Remove 'ignore3' and 'ignore5' CpG-methylation calls from consideration
    if args.ignore3 > 0:
        CpG_index1 = ignore3(args.ignore3, CpG_index1, read_1.rlen, orientation.rsplit('/')[0])
        CpG_index2 = ignore3(args.ignore3, CpG_index2, read_2.rlen, orientation.rsplit('/')[1])
    if args.ignore5 > 0:
        CpG_index1 = ignore5(args.ignore5, CpG_index1, read_1.rlen, orientation.rsplit('/')[0])
        CpG_index2 = ignore5(args.ignore5, CpG_index2, read_2.rlen, orientation.rsplit('/')[1])      
    # Case1: Read-pair is informative for the OT strand
    if strand == 'OT': # For the two-strand protocol, strand == 'OT' is the same as orientation == '+/-'
        # CaseA: > 0 CpGs in both reads of read-pair    
        if (len(CpG_index1) > 0 and len(CpG_index2) > 0):
            if pairChoice == "outermost":
                output = []
                CpGL = CpG_index1[0] # Leftmost CpG in read_1
                CpGR = CpG_index2[-1] # Rightmost CpG in read_2
                positionL = start1 + CpGL
                positionR = start2 + CpGR
                output.append([chrom, positionL, positionR, read_1XM[CpGL], read_2XM[CpGR], strand]) # Output is left-to-right, thus read_1XM appears before read_2XM for OT read-pairs.
                if positionL >= positionR:
                    print "ERROR: Case1A posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_2XM[CpGR], strand]
                    output = []
            elif pairChoice == 'all':
                output = []
                # First, create all CpG-pairs where CpGL is from read_1 and CpGR is from read_1
                if len(CpG_index1) > 1:
                    for i in range(0, len(CpG_index1)): 
                        if i < len(CpG_index1):
                            j = i + 1
                            for k in range(j, len(CpG_index1)):
                                CpGL = CpG_index1[i]
                                CpGR = CpG_index1[k]
                                positionL = start1 + CpGL
                                positionR = start1 + CpGR
                                output.append([chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand])
                                if positionL >= positionR:
                                    print "ERROR: Case1A posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand]
                                    output = []
                # Next, create all CpG-pairs where CpGL is from read_1 and CpGR is from read_2
                for i in range(0, len(CpG_index1)):
                    for j in range(0, len(CpG_index2)):
                        CpGL = CpG_index1[i]
                        CpGR = CpG_index2[j]
                        positionL = start1 + CpGL
                        positionR = start2 + CpGR
                        output.append([chrom, positionL, positionR, read_1XM[CpGL], read_2XM[CpGR], strand]) # Output is left-to-right, thus read_1XM appears before read_2XM for OT read-pairs.
                        if positionL >= positionR:
                            print "ERROR: Case1A posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_2XM[CpGR], strand]
                            output = []
                # Finally, create all CpG-pairs where CpGL is from read_2 and CpGR is from read_2
                if len(CpG_index2) > 1:
                    for i in range(0, len(CpG_index2)): 
                        if i < len(CpG_index2):
                            j = i + 1
                            for k in range(j, len(CpG_index2)):
                                CpGL = CpG_index2[i]
                                CpGR = CpG_index2[k]
                                positionL = start2 + CpGL
                                positionR = start2 + CpGR
                                output.append([chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand])
                                if positionL >= positionR:
                                    print "ERROR: Case1A posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand]
                                    output = []
        # CaseB: > 1 CpG in read_1 but 0 CpGs in read_2
        elif (len(CpG_index1) > 1 and len(CpG_index2) == 0):
            if pairChoice == "outermost":
                output = []
                CpGL = CpG_index1[0]
                CpGR = CpG_index1[-1]
                positionL = start1 + CpGL
                positionR = start1 + CpGR
                output.append([chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand])
                if positionL >= positionR:
                    print "ERROR: Case1B posL >= posR for read ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand]
                    output = []
            elif pairChoice == 'all':
                output = []
                for i in range(0, len(CpG_index1)): 
                    if i < len(CpG_index1):
                        j = i + 1
                        for k in range(j, len(CpG_index1)):
                            CpGL = CpG_index1[i]
                            CpGR = CpG_index1[k]
                            positionL = start1 + CpGL
                            positionR = start1 + CpGR
                            output.append([chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand])
                            if positionL >= positionR:
                                print "ERROR: Case1B posL >= posR for read ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand]
                                output = []
                
        # CaseC: 0 CpGs in read_1 but > 1 CpG in read_2
        elif (len(CpG_index1) == 0 and len(CpG_index2) > 1):
            if pairChoice == "outermost":
                output = []
                CpGL = CpG_index2[0]
                CpGR = CpG_index2[-1]
                positionL = start2 + CpGL
                positionR = start2 + CpGR
                output.append([chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand])
                if positionL >= positionR:
                    print "ERROR: Case1C posL >= posR for read ", read_2.qname," with output ", [chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand]
                    output = []
            elif pairChoice == 'all':
                output = []
                for i in range(0, len(CpG_index2)): 
                    if i < len(CpG_index2):
                        j = i + 1
                        for k in range(j, len(CpG_index2)):
                            CpGL = CpG_index2[i]
                            CpGR = CpG_index2[k]
                            positionL = start2 + CpGL
                            positionR = start2 + CpGR
                            output.append([chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand])
        # CaseD: < 2 CpGs in read-pair
        elif (len(CpG_index1) + len(CpG_index2)) < 2:
            output = []
    # Case2: Read-pair is informative for the OB strand
    elif strand == 'OB': # For the two-strand protocol, strand == 'OB' is the same as orientation == '-/+'
        # CaseA:  > 0 CpGs in both reads of read-pair 
        if (len(CpG_index1) > 0 and len(CpG_index2) > 0):
            if pairChoice == "outermost":
                output = []
                CpGL = CpG_index2[0] # Leftmost CpG in read_2
                CpGR = CpG_index1[-1] # Rightmost CpG in read_1
                positionL = start2 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG 
                positionR = start1 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                output.append([chrom, positionL, positionR, read_2XM[CpGL], read_1XM[CpGR], strand]) # Output is left-to-right, thus read_2XM appears before read_1XM for OB read-pairs.
                if positionL >= positionR:
                    print "ERROR: Case2A posL >= posR for read-pair ", read_1.qname," with output ",  [chrom, positionL, positionR, read_2XM[CpGL], read_1XM[CpGR], strand]
                    output = []
            elif pairChoice == 'all':
                output = []
                # First, create all CpG-pairs where CpGL is from read_1 and CpGR is from read_1
                if len(CpG_index1) > 1:
                    for i in range(0, len(CpG_index1)): 
                        if i < len(CpG_index1):
                            j = i + 1
                            for k in range(j, len(CpG_index1)):
                                CpGL = CpG_index1[i]
                                CpGR = CpG_index1[k]
                                positionL = start1 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG
                                positionR = start1 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                                output.append([chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand])
                                if positionL >= positionR:
                                    print "ERROR: Case2A posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand]
                                    output = []
                # Next, create all CpG-pairs where CpGL is from read_2 and CpGR if from read_1 (recall that the orientation of OB reads is '-/+', hence read_2 appears to the left of read_1)
                for i in range(0, len(CpG_index2)):
                    for j in range(0, len(CpG_index1)):
                        CpGL = CpG_index2[i]
                        CpGR = CpG_index1[j]
                        positionL = start2 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG
                        positionR = start1 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                        output.append([chrom, positionL, positionR, read_2XM[CpGL], read_1XM[CpGR], strand]) # Output is left-to-right, thus read_2XM appears before read_1XM for OB read-pairs.
                        if positionL >= positionR:
                            print "ERROR: Case2A posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_2XM[CpGL], read_1XM[CpGR], strand]
                            output = []
                # Finally, create all CpG-pairs where CpGL is from read_2 and CpGR is from read_2
                if len(CpG_index2) > 1:
                    for i in range(0, len(CpG_index2)): 
                        if i < len(CpG_index2):
                            j = i + 1
                            for k in range(j, len(CpG_index2)):
                                CpGL = CpG_index2[i]
                                CpGR = CpG_index2[k]
                                positionL = start2 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG
                                positionR = start2 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                                output.append([chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand])
                                if positionL >= positionR:
                                    print "ERROR: Case2A posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand]
                                    output = []
        # CaseB: > 1 CpG in read_1 but 0 CpGs in read_2
        elif (len(CpG_index1) > 1 and len(CpG_index2) == 0):
            if pairChoice == "outermost":
                output = []
                CpGL = CpG_index1[0] # Leftmost CpG in read_1
                CpGR = CpG_index1[-1] # Rightmost CpG in read_1
                positionL = start1 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG 
                positionR = start1 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                output.append([chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand])
                if positionL >= positionR:
                    print "ERROR: Case2B posL >= posR for read ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand]
                    output = []
            elif pairChoice == 'all':
                output = []
                for i in range(0, len(CpG_index1)): 
                    if i < len(CpG_index1):
                        j = i + 1
                        for k in range(j, len(CpG_index1)):
                            CpGL = CpG_index1[i]
                            CpGR = CpG_index1[k]
                            positionL = start1 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG
                            positionR = start1 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                            output.append([chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand])
                            if positionL >= positionR:
                                print "ERROR: Case2B posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_1XM[CpGL], read_1XM[CpGR], strand]
                                output = []
        # CaseC: 0 CpGs in read_1 but > 1 CpG in read_2
        elif (len(CpG_index1) == 0 and len(CpG_index2) > 1):
            if pairChoice == "outermost":
                output = []
                CpGL = CpG_index2[0] # Leftmost CpG in read_2
                CpGR = CpG_index2[-1] # Rightmost CpG in read_2
                positionL = start2 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG
                positionR = start2 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                output.append([chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand])
                if positionL >= positionR:
                    print "ERROR: Case2C posL >= posR for read ", read_2.qname," with output ", [chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand]
                    output = []
            elif pairChoice == 'all':
                output = []
                for i in range(0, len(CpG_index2)): 
                    if i < len(CpG_index2):
                        j = i + 1
                        for k in range(j, len(CpG_index2)):
                            CpGL = CpG_index2[i]
                            CpGR = CpG_index2[k]
                            positionL = start2 + CpGL - 1 # -1 so as to point to C on the OT strand in the CpG
                            positionR = start2 + CpGR - 1 # -1 so as to point to C on the OT strand in the CpG
                            output.append([chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand])
                            if positionL >= positionR:
                                print "ERROR: Case2C posL >= posR for read-pair ", read_1.qname," with output ", [chrom, positionL, positionR, read_2XM[CpGL], read_2XM[CpGR], strand]
                                output = []
        # CaseD: < 2 CpGs in read-pair
        elif (len(CpG_index1) + len(CpG_index2)) < 2:
            output = []
    return output

## getStrand() returns whether the read or read-pair is informative for the OT (original top, Watson) or OB (original bottom, Crick) strand.
def getStrand(read_1, read_2):
    if read_2 == "NA": # Single-end data
        if read_1.opt('XG') == 'CT': # Read aligned to CT-converted reference genome and therefore informative for the OT-strand
            strand = 'OT'
        elif read_1.opt('XG') == 'GA': # Read aligned to GA-converted reference genome and therefore informative for the OB-strand
            strand = 'OB'
    else: # Paired-end data
        if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT': # Read-pair aligned to CT-converted reference genome and therefore informative for the OT-strand
            strand = 'OT'
        elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' : # Read-pair aligned to GA-converted reference genome and therefore informative for the OB-strand
            strand = 'OB'
        else:
            error_message = ''.join(['Read-pair is aligned to both the CT- and GA-converted reference genomes: ', read_1.qname]) 
            sys.exit(error_message)
    return strand

## reorganiseCpGPairs() re-orginises the CpG_pairs object so that it can be iterated in a chromosome- or chromosome/position1- or chromosome/position1/position2-manner
## reorganiseCpGPairs() dictionary structure:
## reorganiseCpGPairs()             keys = (chr1, chr2, ..., chrX, chrY), values = chr_wf (the positions of the first CpG in the pair)
##       chr_wf                     keys = (pos1._1, pos1._2, ..., pos1._m), values = pos2 (the position of the second CpG in the pair)
##              pos2                keys = (pos12_1, pos12_2, pos21_2, pos31_2, ..., posm2_n), values = 
##                   makeWFCount    keys = (M, M_OT, M_OB, U, ..., beta, beta_OT, beta_OB, gamma, gamma_OT, gamma_OB), values = 'count'
def reorganiseCpGPairs(CpG_pairs):
    CpG_pairs_reorganised = {}
    for CpG_pair_ID in CpG_pairs.iterkeys():
        chrom, pos1, pos2 = CpG_pair_ID.rsplit(':') # Split the CpG_ID into the chromosome and positions parts.
        pos1 = int(pos1) # Convert pos1 from a string to an integer so that it can be sorted numerically
        pos2 = int(pos2) # Convert pos2 from a string to an integer so that it can be sorted numerically
        if chrom not in CpG_pairs_reorganised: # No CpG-pairs yet seen for this chromosome - create a dictionary for CpG-pairs on this chromosome
            CpG_pairs_reorganised[chrom] = {}
        if pos1 not in CpG_pairs_reorganised[chrom]: # No CpG-pairs yet seen starting at this position - create a dictionary for CpG-pairs starting at this position
            CpG_pairs_reorganised[chrom][pos1] = {}
        # Add the comethylation data for this CpG-pair on this chromosome, starting at pos1 and ending at pos2
        CpG_pairs_reorganised[chrom][pos1][pos2] = CpG_pairs[CpG_pair_ID]
    return CpG_pairs_reorganised
        
## WFWriter writes a tab-separated output file to the filehandle WF
WFWriter = csv.writer(WF, delimiter='\t', quotechar=' ', quoting=csv.QUOTE_MINIMAL)

## writeWF() writes the CpG_pairs_reorganised object to disk as a tab-separated file.
def writeWF(CpG_pairs_reorganised):
    # Create the header row
    header = ['chr', 'pos1', 'pos2']
    #example_row = CpG_pairs_reorganised[CpG_pairs_reorganised.keys()[0]][CpG_pairs_reorganised[CpG_pairs_reorganised.keys()[0]].keys()[0]][CpG_pairs_reorganised[CpG_pairs_reorganised.keys()[0]][CpG_pairs_reorganised[CpG_pairs_reorganised.keys()[0]].keys()[0]].keys()[0]]
    example_row = makeWFCount()
    for key in sorted(example_row.iterkeys()):
        header.append(key)
    # Write the header to file
    WFWriter.writerow(header)
    # Write each CpG-pair to file
    for chromosome in sorted(CpG_pairs_reorganised.iterkeys()): # Loop over a single chromosome
        print '\t', chromosome
        for pos1 in sorted(CpG_pairs_reorganised[chromosome].iterkeys()): # Loop over all pos1 in that chromosome
            for pos2 in sorted(CpG_pairs_reorganised[chromosome][pos1].iterkeys()): # Loop over all CpG-pairs that start at the current pos1
                pair_counts = []
                for count in sorted(CpG_pairs_reorganised[chromosome][pos1][pos2].iterkeys()):
                    pair_counts.append(CpG_pairs_reorganised[chromosome][pos1][pos2][count])
                row = [chromosome, pos1, pos2] + pair_counts
                WFWriter.writerow(row)

    
#############################################################################################################################################################################################

### Variable initialisations ###
#############################################################################################################################################################################################
CpG_pattern = re.compile(r"[Zz]")
if (args.phred64):
    PhredOffset = 64
else:
    PhredOffset = 33
minQual = args.minQual
pairChoice = args.pairChoice
n_fragment = 0 # The number of DNA fragments. One single-end read and one paired-end read contribute a single DNA fragment.
n_comethylation_fragment = 0 #  The number of DNA fragments with a co-methylation measurement. One single-end read and one paired-end read contribute a single DNA fragment.
CpG_pairs = {} # Dictionary of CpG pair IDs with keys of form chr_pos1_pos2 and values corresponding to a makeWFCount object 
#############################################################################################################################################################################################

### The main program. Loops over the BAM file line-by-line (i.e. alignedRead-by-alignedRead) and extracts the XM information for each read or read-pair. ###
#############################################################################################################################################################################################
if pairChoice != 'all' and pairChoice != 'outermost':
    sys.exit('ERROR: --pairchoice must be one of \'all\' or \'outermost\'')
print 'Assuming quality scores are Phred', PhredOffset
print 'Ignoring', args.ignore3, 'bp from 3\' end of each read'
print 'Ignoring', args.ignore5, 'bp from 5\' end of each read'
print 'Ignoring CpG-methylation calls with base-quality less than', minQual
print 'Creating', pairChoice, 'CpG-pairs'
for read in BAM:
    fragment_MS = None # Reset the fragment_MS to None to erase values from previous reads/read-pairs
    if args.ignoreDuplicates and read.is_duplicate:
        if not read.is_paired:
            n_fragment += 1
        else:
            n_fragment += 0.5 # Want to count the number of FRAGMENTS not the number of reads.
        continue
    elif read.is_paired and not read.is_proper_pair:
        print "WARNING: Skipping read ", read.qname, " as it is part of an improper pair."
        n_fragment += 0.5 # Want to count the number of FRAGMENTS not the number of reads.
        continue
    else:
        if read.is_proper_pair and read.is_read_1:
            read_1 = read
            continue
        elif read.is_proper_pair and read.is_read_2: 
            read_2 = read
            n_fragment += 1
            # Check that read_1 and read_2 are aligned to the same chromosome and have identical read-names. If not, skip the read-pair.
            if read_1.tid == read_2.tid and read_1.qname == read_2.qname:
                fragment_MS = SAM2MS_PE(read_1, read_2)
            elif read_1.tid != read_2.tid:
                print "ERROR: Reads in pair aligned to different chromosomes: ", read_1.qname, BAM.getrname(read_1.tid), read_2.qname, BAM.getrname(read_2.tid)
                continue
            elif read_1.qname != read_2.qname:
                print "ERROR: The name of read_1 is not identical to to that of read_2 for read-pair ", read_1.qname, read_2.qname, "\nHas your BAM file been sorted in query-name-order with Picard's SortSam function?"
                continue
        elif not read.is_paired:
            n_fragment += 1  
            fragment_MS = SAM2MS_SE(read)
        else:
            print "Read is neither a single-end read nor part of a paired-end read. Check the SAM flag values are correctly set for read:", read.qname
            continue
    #if fragment_MS is not None:
    #    n_comethylation_fragment += 1
    #    pair_ID = ':'.join([fragment_MS[0], str(fragment_MS[1]), str(fragment_MS[2])])
    #    if not pair_ID in CpG_pairs: # CpG-pair not yet seen - create a dictionary key for it and increment its count (value)
    #        CpG_pairs[pair_ID] = makeWFCount()
    #        CpG_pairs[pair_ID] = incrementWFCount(CpG_pairs[pair_ID], fragment_MS, read.qname) 
    #    else: # CpG-pair already seen - increment its count (value)
    #        CpG_pairs[pair_ID] = incrementWFCount(CpG_pairs[pair_ID], fragment_MS, read.qname)
    if len(fragment_MS) > 0: # Check whether there were any CpG-pairs identified in that DNA fragment by SAM2MS_SE() or SAM2MS_PE()
        n_comethylation_fragment += 1
        for i in range(0, len(fragment_MS)): # Loop over each CpG-pair in fragment_MS
            pair_ID = ':'.join([fragment_MS[i][0], str(fragment_MS[i][1]), str(fragment_MS[i][2])]) # pair_ID is of form 'chrom:pos1:pos2'
            if not pair_ID in CpG_pairs: # CpG-pair not yet seen - create a dictionary key for it and increment its count (value)
                CpG_pairs[pair_ID] = makeWFCount()
                CpG_pairs[pair_ID] = incrementWFCount(CpG_pairs[pair_ID], fragment_MS[i], read.qname) 
            else: # CpG-pair already seen - increment its count (value)
                CpG_pairs[pair_ID] = incrementWFCount(CpG_pairs[pair_ID], fragment_MS[i], read.qname)

# Store CpG-pairs as a dictionary of dictionaries. The returned object is accessible by chromosome, then position.
print 'Re-organising CpG-pairs in chromosomes-position order...'
CpG_pairs_reorganised = reorganiseCpGPairs(CpG_pairs)

# Write results to disk
print 'Writing CpG-pairs to', WF.name, '...'
writeWF(CpG_pairs_reorganised)

BAM.close()
WF.close()

print 'Number of DNA fragments in file:', n_fragment
print 'Number of DNA fragments informative for comethylation:', n_comethylation_fragment, '(', round(n_comethylation_fragment / float(n_fragment) * 100, 1), '%)'
##############################################################################################################################################################################################
