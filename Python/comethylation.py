#!/usr/bin/env python
import re
from numpy import array
import argparse
import sys
import csv
import pysam
import warnings
from operator import itemgetter, attrgetter
import itertools
from math import floor

#### LICENSE ####
## Copyright (C) 2012 - 2014 Peter Hickey (peter.hickey@gmail.com)

## This file is part of Comethylation.

## Comethylation is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 2 of the License, or
## (at your option) any later version.
## Comethylation is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with Comethylation.  If not, see <http://www.gnu.org/licenses/>.

#### Program description ####
# Extract within-fragment co-methylation measurements at methylation loci for the aligned reads from a BS-Seq experiment.
# SAM/BAM must be generated by Bismark. Other aligners may be supported in future releases. The SAM/BAM file must comply with the SAM spec (v1.4). The Bismark SAM file from version < 0.8.3 does not comply with these standards and must be pre-processed with correct_Bismark.py. The reason for this is that the Bismark SAM file does not correctly encode the orientation of readpairs in the SAM flag field.
# The SAM/BAM can contain single-end reads, paired-end reads or a combination of the two types. The type of sequencing performed is determined by checking whether the 0x01 flag bit is set ("template being sequenced has multiple fragments"). SAM/BAM files containing paired-end reads must be sorted by query-name using Picard's SortSam function.
# Methylation loci are identified by examining the XM-tag of each read. The XM-tag is reference-based, so only reference methylation loci are examined. This means that sample-specific methylation loci are ignored and reference-specific methylation loci, which may not be methylation loci in the sample of interest, are also examined.
# This program is an extension of comethylation.py (v2) to m-tuples from 2-tuples.
# There are two types of comethylation: (1) Within-fragment co-methylation (WF), which is the dependence of methylation states along a DNA read/fragment/chromosome that contains multiple methylation loci; and (2) correlation of aggregate methylation values (AM). Aggregate methylation values are based on the pileup of reads at each methylation locus and include beta = M/(U+M) and gamma = log((M + eps)/(U + eps)), where M = the number of methylated Cs, U = the number of unmethylated Cs and esp is a small number to ensure numerical stability of gamma, typically esp = 0.5.
# comethylation.py extracts the necessary information to analyse both (1) and (2), but it does not perform the statistical analysis.
# If the reads from a readpair overlap then, provided the overlapping sequence passes the filter specified by --overlappingPairedEndFilter, we trim the lower quality read until no overlap remains. If the overlapping sequence does not pass the filter specified by --overlappingPairedEndFilter then we ignore the readpair. This behaviour may be altered in future releases.

#### Description of sampleName.methylationType.mTuple.tsv ####
# Fields are tab-delimited.
# Each line corresponds to a methylation-loci m-tuple and includes a count of each type of m-tuple in the form [chromosome pos_1 ... pos_m counts_1 ... counts_2^m]
# There are 2^m possible m-tuples and these are alphabetically ordered in the output
# Only "bookended" methylation-loci m-tuples can be created.
# WARNING: methylation-loci m-tuples that span both mates of a readpair may have NIC > 0. Furthermore, filtering by base quality, read-position, etc. may also introduce methylation-loci m-tuples with NIC > 0. These should be post-hoc filtered.

#### Explanation of XM-tag (methylation string). NB: This is an extension to the XM-tag defined in Bismark. ####
# . for bases not involving cytosines                       
# X for methylated C in CHG context (was protected)         
# x for not methylated C in CHG context (was converted)     
# H for methylated C in CHH context (was protected)         
# h for not methylated C in CHH context (was converted)     
# Z for methylated C in CpG context (was protected)         
# z for not methylated C in CpG context (was converted)
# U for methylated C in "unknown" context, e.g. CNN-context, (was protected). Non-standard Bismark XM-tag values; unique to output of XM_tag.py.
# u for not methylated C in "unknown"-context, e.g. CNN-context, (was converted). Non-standard Bismark XM-tag values; unique to output of XM_tag.py.

#### Command line parser ####
parser = argparse.ArgumentParser(description='Extract within-fragment co-methylation measurements at CpGs from the aligned reads of a BS-Seq experiment. WARNING: Currently only works for the two-strand BS-seq protocol for reads without soft-clipping or indels. Requires Bismark-style BAM files including XG-, XR- and XM-tags and corrected SAM flags.')
parser.add_argument('BAM', metavar = 'BAM',
                    help ='The path to the SAM/BAM file')
parser.add_argument('sampleName',
                    metavar = 'sampleName',
                    help = 'The name of the sample. All output files will have this prefix.')
parser.add_argument('--mTuple', metavar = '<int>',
                    type = int,
                    default=2,
                    help='The size of the methylation-loci m-tuples (i.e. the choice of m); must be an integer > 1 (default: 2).')
parser.add_argument('--methylationType', metavar = '<string>',
                    default ="CG",
                    help='The type of methylation loci to study: CG or CHG (default: CG; CHH not yet implemented).')
parser.add_argument('--oldBismark',
                    action = 'store_true',
                    help ='SAM/BAM created with Bismark version < 0.8.3. The FLAG and QNAME field in SAM/BAM files created by these older versions of Bismark differed from the SAM specifications and need to be adjusted on the fly by comethylation.py')
parser.add_argument('--ignoreDuplicates',
                    action = 'store_true',
                    help ='Ignore reads that have been flagged as PCR duplicates by Picard\'s MarkDuplicates function')
parser.add_argument('--ignoreImproperPairs',
                    action = 'store_true',
                    help ='Ignore improper readpairs')
parser.add_argument('--ignoreStart_r1', metavar = '<int>',
                    type = int,
                    default=0,
                    help="Ignore first <int> bases from start (5' end) of read (respectively, read_1) for single-end data (respectively, paired-end data) (default: 0). WARNING: Parameter value not sanity checked by program.")
parser.add_argument('--ignoreStart_r2', metavar = '<int>',
                    type = int,
                    default=0,
                    help="Only used if data are paired-end. Ignore first <int> bases from start (5' end) of read_2 (default: 0). WARNING: Parameter value not sanity checked by program.")
parser.add_argument('--ignoreEnd_r1', metavar = '<int>',
                    type = int,
                    default=0,
                    help="Ignore last <int> bases from end (3' end) of read (respectively, read_1) for single-end data (respectively, paired-end data) (default: 0). WARNING: Parameter value not sanity checked by program.")
parser.add_argument('--ignoreEnd_r2', metavar = '<int>',
                    type = int,
                    default=0,
                    help="Only used if data are paired-end. Ignore last <int> bases from end (5' end) of read_2 (default: 0). WARNING: Parameter value not sanity checked by program.")
parser.add_argument('--minQual', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Minimum base-quality (default: 0). Any base with a lower base-quality is ignored.')
parser.add_argument('--minMapQ', metavar = '<int>',
                    type = int,
                    default=0,
                    help='Minimum mapping quality mapQ (default: 0). Any read with a lower mapQ is ignored. WARNING: This option has no effect with SAM/BAM files created with Bismark. Bismark sets all mapQ values to 255, which indicates that the mapping quality is not available.')
parser.add_argument('--phred64',
                    action = 'store_true',
                    help='Quality scores are encoded as Phred64 (default: Phred33).')
parser.add_argument('--overlappingPairedEndFilter', metavar = '<string>',
                    default = 'XM',
                    help="What filter should be applied to any overlapping paired-end reads. Read-pairs that don't pass the filter are not used for methylation calling (options listed by most-to-least stringent): check the entire overlapping sequence is identical (sequence), check the XM-tag is identical for the overlapping region (XM), do no check of the overlapping bases but use the read with the higher quality basecalls in the overlapping region (none), do no check of the overlapping bases and just use the overlapping bases from read_1 ala bismark_methylation_extractor (bismark) (default: XM).")
parser.add_argument('--strandSpecific',
                    action = 'store_true',
                    help = "Produce strand-specific counts, i.e. don't collapse methylation calls across Watson and Crick strands (default for CHH methylation)")
parser.add_argument('--version',
                    action='version', version='%(prog)s 0.3.1')

args = parser.parse_args()

#### Open SAM/BAM file and output files ####
BAM = pysam.Samfile(args.BAM)
OUT = open(".".join([args.sampleName, args.methylationType, str(args.mTuple), "tsv"]), "w")
HIST = open("".join([args.sampleName, ".", args.methylationType, "_per_read.hist"]), "w")

#### Function definitions ####
def ignore_first_n_bases(read, methylation_index, n):
    """Ignore methylation loci occuring in the first n bases of a read. A methylation locus may be one of CpG, CHH, CHG or CNN.

    Args:
        read: A pysam.AlignedRead instance.
        methylation_index: A list of zero-based indices. Each index corresponds to the leftmost aligned position of a methylation locus in a read. For example:

        [0, 5]

        corresponds to a read with a methylation locus at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.

    Returns:
        An updated version of methylation_index.
    """
    ignore_these_bases = []
    # Single-end reads
    if not read.is_paired:
        # Read aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        # Read aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_1
    elif read.is_paired and read.is_read1:
        # read_1 aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        # read_1 aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_2
    elif read.is_paired and read.is_read2:
        # read_2 aligned to OT-strand <------|
        if read.opt('XG') == 'CT' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        # read_2 aligned to OB-strand |------>
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Skipping read because it does not have necessary information to infer whether read is paired or whether the read is read_1 or read_2 of the readpair.
    else:
        warning_msg = ''.join(['Skipping read ', read.qname, '. Missing 0x01, 0x40 or 0x80 FLAG bit (paired-read FLAG information)'])
        warnings.warn(warning_msg)
        methylation_index = []
    return [x for x in methylation_index if x not in ignore_these_bases]

def ignore_last_n_bases(read, methylation_index, n):
    """Ignore methylation loci occuring in the last n bases of a read. A methylation locus may be one of CpG, CHH, CHG or CNN.

    Args:
        read: A pysam.AlignedRead instance.
        methylation_index: A list of zero-based indices. Each index corresponds to the leftmost aligned position of a methylation locus in a read. For example:

        [0, 5]

        corresponds to a read with a methylation locus at the first and sixth positions of the read.
        n: The number of bases to exclude from the start of each read. The start of a read is the first *sequenced* base, not the leftmost aligned base.

    Returns:
        An updated version of methylation_index.
    """
    ignore_these_bases = []
    # Single-end reads
    if not read.is_paired:
        # Read aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        # Read aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_1
    elif read.is_paired and read.is_read1:
        # read_1 aligned to OT-strand |------>
        if read.opt('XG') == 'CT' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i >= (read.alen - n):
                    ignore_these_bases.append(i)
        # read_1 aligned to OB-strand <------|
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Paired-end reads: read_2
    elif read.is_paired and read.is_read2:
        # read_2 aligned to OT-strand <------|
        if read.opt('XG') == 'CT' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i < n:
                    ignore_these_bases.append(i)
        # read_2 aligned to OB-strand |------>
        elif read.opt('XG') == 'GA' and read.opt('XR') == 'GA':
            for i in methylation_index:
                if i  >= (read.alen - n):
                    ignore_these_bases.append(i)
        else:
            warning_msg = ''.join(['Skipping read ', read.qname, '. Incompatible or missing XG-tag or XR-tag.'])
            warnings.warn(warning_msg)
            methylation_index = []
    # Skipping read because it does not have necessary information to infer whether read is paired or whether the read is read_1 or read_2 of the readpair.
    else:
        warning_msg = ''.join(['Skipping read ', read.qname, '. Missing 0x01, 0x40 or 0x80 FLAG bit (paired-read FLAG information)'])
        warnings.warn(warning_msg)
        methylation_index = []
    return [x for x in methylation_index if x not in ignore_these_bases]
        
def ignore_low_quality_bases(read, methylation_index, min_qual, phred_offset):
    """Ignore low quality bases of a read that contribute to a read's methylation_index.

    Args:
        read: A pysam.AlignedRead instance.
        methylation_index: A list of zero-based indices. Each index corresponds to the leftmost aligned position of a methylation locus in a read. For example:

        [0, 5]

        corresponds to a read with a methylation locus at the first and sixth positions of the read.
        min_qual: The minimum base quality (integer). All bases with quality < min_qual are excluded from the returned methylation_index instance.
        phred_offset: The Phred offset of the data (33 or 64).

    Returns:
        An updated version of methylation_index.
    
    """
    ignore_these_bases = []
    for i in methylation_index:
        if (ord(read.qual[i]) - phred_offset) < min_qual:
            ignore_these_bases.append(i)
    return [x for x in methylation_index if x not in ignore_these_bases]

def fix_old_bismark(read):
	"""Fix the QNAME and FLAG field of a paired-end read from a SAM/BAM file generated by Bismark version < 0.8.3

	Args:
		read: A pysam.AlignedRead instance.

	Returns:
		An updated version of the read.
    
	"""
	# Strip '/1' or '/2' appended to the end of QNAMEs by Bismark version < 0.8.3. Assumes there are no forward slash characters in the QNAME field
	read.qname = read.qname.split('/')[0]
	# Fix FLAG value
	if read.flag == 67:
		read.flag = 99
	elif read.flag == 115:
		read.flag = 83
	elif read.flag == 131:
		read.flag = 147
	elif read.flag == 179:
		read.flag = 163
	else:
		exit_msg = ''.join(['Unexpected FLAG (', str(read.flag), ') for read ', read.qname, 'Sorry, --oldBismark is unable to deal with this FLAG. Please log an issue at www.github.com/PeteHaitch/Comethylation describing the error or email me at peter.hickey@gmail.com.'])
		sys.exit(exit_msg)
	return read    

def is_overlapping_sequence_identical(read_1, read_2, n_overlap, overlap_check):
    """Check whether the overlapping sequence of read_1 and read_2 passes the filter specified by overlap_check

    Args:
        read_1: A pysam.AlignedRead instance with read.is_read1 == true. Must be paired with read_2.
        read_2: A pysam.AlignedRead instance with read.is_read2 == true. Must be paired with read_1.
        n_overlap: The number of bases in the overlap of read_1 and read_2 (must be > 0)
        overlap_check: The type of check to be performed (listed by most-to-least stringent): check the entire overlapping sequence is identical (sequence), check the XM-tag is identical for the overlapping region (XM), do no check of the overlapping bases but use the read with the higher quality basecalls in the overlapping region (none), or simply use the overlapping bases from read_1 ala bismark_methylation_extractor (bismark)

    Returns:
        True if the overlapping sequence passes the filter, False otherwise (NB: this means that readpairs that trigger the warning for having mis-specified XG- or XR-tags will also return 'False').
    """
    # Readpair aligns to OT-strand
    if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        if overlap_check == 'sequence':
            overlap_1 = read_1.seq[-n_overlap:]
            overlap_2 = read_2.seq[:n_overlap]
        elif overlap_check == 'XM':
            overlap_1 = read_1.opt('XM')[-n_overlap:]
            overlap_2 = read_2.opt('XM')[:n_overlap]
        elif overlap_check == 'bismark': # return True as Bismark does not actually check the overlapping sequence but rather just takes the overlap from read_1
            overlap_1 = True
            overlap_2 = True
        elif overlap_check == 'none':
            overlap_1 = True
            overlap_2 = True
    # Readpair aligns to OB-strand
    elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        if overlap_check == 'sequence':
            overlap_1 = read_1.seq[:n_overlap]
            overlap_2 = read_2.seq[-n_overlap:]
        elif overlap_check == 'XM':
            overlap_1 = read_1.opt('XM')[:n_overlap]
            overlap_2 = read_2.opt('XM')[-n_overlap:]
        elif overlap_check == 'bismark': # return True as Bismark does not actually check the overlapping sequence but rather just takes the overlap from read_1
            overlap_1 = True
            overlap_2 = True
        elif overlap_check == 'none':
            overlap_1 = True
            overlap_2 = True
    else:
        warning_msg = ''.join(['XG-tags or XR-tags for readpair ', read.qname, ' are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
        warnings.warn(warning_msg)
        overlap_1 = True
        overlap_2 = False
    return overlap_1 == overlap_2

def does_read_contain_indel(read):
    """Check whether a read contains an insertion or deletion (InDel).

    Args:
        read: A pysam.AlignedRead instance.

    Returns:
        True if read contains an INDEL, False otherwise.
    """
    val = any([x[0] in [1, 2] for x in read.cigar]) # In pysam, the CIGAR operation for an insertion to the reference is 1 and the CIGAR operation for a deletion to the reference is 2.
    return val

def does_read_contain_complicated_cigar(read):
    """Check whether a read contains a complicated CIGAR string character, defined as anything other than a match (M; 0), insertion (I; 1) or deletion (D; 2).

    Args:
        read: A pysam.AlignedRead instance.

    Returns:
        True if read contains an complicated CIGAR string character, False otherwise.
    """
    val = any([x[0] not in [0, 1, 2] for x in read.cigar]) # In pysam, the CIGAR operation for an insertion to the reference is 1 and the CIGAR operation for a deletion to the reference is 2.
    return val

def ignore_overlapping_sequence(read_1, read_2, methylation_index_1, methylation_index_2, n_overlap, overlap_check):
    """Ignore the overlapping sequence of read_1 and read_2 from the read with the lower (sum) base qualities in the overlapping region.
       If base qualities are identical then (arbitrarily) ignore the overlapping bases from read_2.

    Args:
        read_1: A pysam.AlignedRead instance with read.is_read1 == true. Must be paired with read_2.
        read_2: A pysam.AlignedRead instance with read.is_read2 == true. Must be paired with read_1.
        methylation_index_1: A list of zero-based indices.  Each index corresponds to the leftmost aligned position of a methylation locus in read_1. For example:

        [0, 5]

        corresponds to read_1 with a methylation locus at the first and sixth positions of the read.
        methylation_index_2: As for methylation_index_1 but informative for read_2.
        n_overlap: The number of bases in the overlap (must be > 0).
        overlap_check: The type of check to be performed (listed by most-to-least stringent): check the entire overlapping sequence is identical (sequence), check the XM-tag is identical for the overlapping region (XM), do no check of the overlapping bases but use the read with the higher quality basecalls in the overlapping region (none), or simply use the overlapping bases from read_1 ala bismark_methylation_extractor (bismark)

    Returns:
        Updated versions of methylation_index_1 and methylation_index_2.
    """
    ignore_these_bases = []
    # Readpair aligns to OT-strand
    if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_quals_1 = sum([ord(x) for x in read_1.qual[-n_overlap:]])
        overlap_quals_2 = sum([ord(x) for x in read_2.qual[-n_overlap:]])
        if (overlap_quals_1 >= overlap_quals_2) | (overlap_check == 'bismark'): # overlap_check == 'bismark' simply means use the overlapping sequence from read_1.
            for i in methylation_index_2:
                if i < n_overlap:
                    ignore_these_bases.append(i)
                    methylation_index_2 = [x for x in methylation_index_2 if x not in ignore_these_bases]
        else:
            for i in methylation_index_1:
                if i >= (read_1.alen - n_overlap):
                    ignore_these_bases.append(i)
                    methylation_index_1 = [x for x in methylation_index_1 if x not in ignore_these_bases]
    # Readpair aligns to OB-strand
    elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
        overlap_quals_1 = sum([ord(x) for x in read_1.qual[:n_overlap]])
        overlap_quals_2 = sum([ord(x) for x in read_2.qual[-n_overlap:]])
        if (overlap_quals_1 >= overlap_quals_2) | (overlap_check == 'bismark'): # overlap_check == 'bismark' simply means use the overlapping sequence from read_1.
            for i in methylation_index_2:
                if i >= (read_2.alen - n_overlap):
                    ignore_these_bases.append(i)
                    methylation_index_2 = [x for x in methylation_index_2 if x not in ignore_these_bases]
        else:
            for i in methylation_index_1:
                if i < n_overlap:
                    ignore_these_bases.append(i)
                    methylation_index_1 = [x for x in methylation_index_1 if x not in ignore_these_bases]
    else:
        warning_msg = ''.join(['Skipping readpair ', read.qname, ' as XG-tags or XR-tags are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
        warnings.warn(warning_msg)
        methylation_index_1 = []
        methylation_index_2 = []
    return methylation_index_1, methylation_index_2

class WithinFragmentComethylationMTuple:
    """A WithinFragmentComethylationMTuple instance stores the within-fragment comethylation counts for a single m-tuple of methylation loci, e.g. a methylation-loci m-tuple.
    
    Attributes:
        chromosome: The chromosome containing the methylation-loci m-tuple.
        chromosome_index: An index to be used when sorting a set of WithinFragmentComethylationMTuple instances by chromosome name.
        m: The "m" in m-tuples, i.e. size of the methylation-loci m-tuples.
        positions: A sorted list of 1-based positions (position_1, position_2, ..., position_m) of length = m-tuple, where position_i is the position of the i-th methylation locus in the methylation-loci m-tuple (with reference to the OT-strand). NB: position_1 < position_2 < ... < position_m by definition.
        methylation_type: The type of methylation event, e.g. CG, CHH or CHG.
        counts: A dictionary storing the counts for each of the 2^m comethylation states combined across strands giving a total of 2^m keys and associated values (counts).
    """
    def __init__(self, chromosome, chromosome_index, m, positions, methylation_type):
        """Initiates WithinFragmentComethylationMTuple for a single m-tuple of methylation events with co-ordinates given by arguments (chromosome, positions) and sets all counts to zero."""
        self.methylation_type = methylation_type
        self.chromosome = chromosome
        self.chromosome_index = chromosome_index
        self.positions = positions
        tmp_k = list((itertools.product(('U', 'M'), repeat = m))) # Step 1 of creating the keys: create all combinations of 'U', 'M' of length m
        k = sorted([''.join(a) for a in tmp_k]) # Sort those keys for consistency's sake
        self.counts = dict(zip(k, [0] * (2 ** m))) # Create the dictionary with all counts set to 0
    def display(self): 
        """Display a WithinFragmentComethylationMTuple instance."""
        print 'Methylation type =', self.methylation_type
        print 'Positions =', self.chromosome, ':', self.positions
        print 'Counts =', self.counts
    def m_tuple_id(self):
        print ''.join([self.chromosome, ':', '-'.join([str(a) for a in self.positions])])
    def increment_count(self, comethylation_state, methylation_type, read_1, read_2):
        """Increment the counts attribute based on the comethylation_state that has been extracted from read_1 and read_2. NB: read_2 should be set to None if data is single-end."""
        # Replace Bismark methylated and unmethylated characters with M and U, depending on the methylation type.
        if methylation_type == 'CG':
            comethylation_state = comethylation_state.replace('Z', 'M')
            comethylation_state = comethylation_state.replace('z', 'U')
        elif methylation_type == 'CHG':
            comethylation_state = comethylation_state.replace('X', 'M')
            comethylation_state = comethylation_state.replace('x', 'U')
        elif methylation_type == 'CHH':
            comethylation_state = comethylation_state.replace('H', 'M')
            comethylation_state = comethylation_state.replace('h', 'U')
        # Single-end
        if read_2 is None and not read_1.is_paired:
            # Check that XG- and XR-tags make sense with 2-strand protocol data
            if (read_1.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and not read_1.is_paired) or ( read_1.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and not read_1.is_paired):
                if comethylation_state in self.counts.keys():
                    self.counts[comethylation_state] += 1
                else:
                    warning_msg = ''.join(['Skipping read ', read_1.qname, ' due to invalid co-methylation string = ', comethylation_state])
                    warnings.warn(warning_msg)
            # Read not compatible with 2-strand protocol, so skip it
            else:
                warning_msg = ''.join(['Skipping read ', read.qname, ' as XG-tags or XR-tags are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
                warnings.warn(warning_msg)
        # Paired-end
        elif read_1.is_paired and read_2.is_paired and read_1.is_read1 and read_2.is_read2:
            if (read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA') or (read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA'):
                if comethylation_state in self.counts.keys():
                    self.counts[comethylation_state] += 1
                else:
                    warning_msg = ''.join(['Skipping read ', read_1.qname, ' due to invalid co-methylation string = ', comethylation_state])
                    warnings.warn(warning_msg)
            elif not read_1.is_read1 or not read_2.is_read2:
                warning_msg = ''.join(['Skipping readpair ', read.qname, ' as read_1 or read_2 does not appear to be correctly set.'])
                warnings.warn(warning_msg)
            # Readpair not compatible with 2-strand protocol, so skip it
            else:
                warning_msg = ''.join(['Skipping readpair ', read.qname, ' as XG-tags or XR-tags are inconsistent with OT-strand or OB-strand (XG-tags = ', read_1.opt('XG'),', ', read_2.opt('XG'), '; XR-tags = ', read_1.opt('XR'), ', ', read_2.opt('XR'), ')'])
                warnings.warn(warning_msg)             

def extract_and_update_methylation_index_from_single_end_read(read, BAM, methylation_m_tuples, m, methylation_type, methylation_pattern, ignore_start_r1, ignore_end_r1, min_qual, min_mapq, phred_offset, ob_strand_offset):
    """Extracts m-tuples of methylation loci from a single-end read and adds the comethylation m-tuple to the methylation_m_tuples object.
    
    Args:
        read: An AlignedRead instance corresponding to a single-end read.
        BAM: The Samfile instance corresponding to the sample. Required in order to extract chromosome names from read.
        methylation_m_tuples: A dictionary storing all observed m-tuples of methylation events and their WithinFragmentComethylationMTuple instance.
        methylation_type: A string of the methylation type, e.g. CG for CpG methylation. Must be a valid option for the WithinFragmentComethylationMTuple class.
        methylation_pattern: A regular expression of the methylation loci, e.g. '[Zz]' for CpG-methylation
        m: Is the "m" in "m-tuple", i.e. the size of the m-tuple. m must be an integer greater than or equal to 1. WARNING: No error or warning produced if this condition is violated.
        ignore_start_r1: How many bases to ignore from start (5' end) of read.
        ignore_end_r1: How many bases to ignore from end (3' end) of read.
        min_qual: Ignore bases with quality-score less than this value.
        min_mapq: Ignore reads with a mapQ less than this value.
        phred_offset: The offset in the Phred scores. Phred33 corresponds to phred_offset = 33 and Phred64 corresponds to phred_offset 64.
        ob_strand_offset: How many bases a methylation loci on the OB-strand must be moved to the left in order to line up with the C on the OT-strand; e.g. ob_strand_offset = 1 for CpGs.
    Returns:
        methylation_m_tuples: An updated version of methylation_m_tuples
        n_methylation_loci: The number of methylation loci extracted from the read.
    """
    # Identify methylation events in read, e.g. CpGs or CHHs. The methylation_pattern is specified by a command line argument (e.g. Z/z corresponds to CpG)
    methylation_index = [midx.start() for midx in re.finditer(methylation_pattern, read.opt('XM'))]
    # Ignore any start or end positions of read if required
    if ignore_start_r1 > 0:
        methylation_index = ignore_first_n_bases(read, methylation_index, ignore_start_r1)
    if ignore_end_r1 > 0:
        methylation_index = ignore_last_n_bases(read, methylation_index, ignore_end_r1)
    # Ignore any positions with a base quality less than min_qual
    methylation_index = ignore_low_quality_bases(read, methylation_index, min_qual, phred_offset)
    # Ignore any reads with mapQ less than min_mapq. Do this by setting the methylation_index = []
    if read.mapq < min_mapq:
        methylation_index = []
        warning_msg = ''.join(['Ignoring read ', read.qname, ' since its mapQ < ', str(min_mapq)])
        warnings.warn(warning_msg)
    n_methylation_loci = len(methylation_index)
    # Case A: >= m methylation loci in the read
    if n_methylation_loci >= m:
        positions = [read.pos + x + 1 for x in methylation_index] # +1 to transform from 0-based to 1-based co-ordinates.
        # If read is aligned to OB-strand then translate co-ordinate "ob_strand_offset" bases to the left so that it points to the C on the OT-strand of the methylation locus.
        if read.opt('XG') == 'GA' and read.opt('XR') == 'CT':
            positions = [x - ob_strand_offset for x in positions]
        # Skip readpair if methylation loci are incorrectly ordered and report a warning.
        if not positions == sorted(positions):
            warning_msg = ' '.join(["Skipping single-end read", read.qname, "as positions aren't properly ordered (Case A)."])
            warnings.warn(warning_msg)
        # Else, construct each bookended methylation-loci m-tuple and add it to the methylation_m_tuple instance.
        else:
            for i in range(0, len(methylation_index) - m + 1): # For a read containing k methylation loci there are (k - m + 1) m-tuples.
                this_m_tuple_positions = positions[i:(i + m)]
                # Create a unique ID for each m-tuple of methylation loci (of form "chromosome:position_1-position_2-...-position_M")
                m_tuple_id = ''.join([BAM.getrname(read.tid), ':', '-'.join([str(j) for j in this_m_tuple_positions])])
                # Check whether m-tuple has already been observed. If not, create a WithinFragmentMethylationMTuple instance for it and increment its count. Otherwise, just increment its count.
                if not m_tuple_id in methylation_m_tuples:
                    methylation_m_tuples[m_tuple_id] = WithinFragmentComethylationMTuple(BAM.getrname(read.tid), read.tid, m, this_m_tuple_positions, methylation_type) # read.tid acts as the chromosome_index required by WithinFragmentComethylationMTuple class
                    methylation_m_tuples[m_tuple_id].increment_count(''.join([read.opt('XM')[j] for j in methylation_index[i:(i + m)]]), methylation_type, read, None)
                else:
                    methylation_m_tuples[m_tuple_id].increment_count(''.join([read.opt('XM')[j] for j in methylation_index[i:(i + m)]]), methylation_type, read, None)
    return methylation_m_tuples, n_methylation_loci

def extract_and_update_methylation_index_from_paired_end_reads(read_1, read_2, BAM, methylation_m_tuples, m, methylation_type, methylation_pattern, ignore_start_r1, ignore_start_r2, ignore_end_r1, ignore_end_r2, min_qual, min_mapq, phred_offset, ob_strand_offset, overlap_check, n_fragment_skipped_due_to_bad_overlap):
    """Extracts m-tuples of methylation loci from a readpair and adds the comethylation m-tuple to the methylation_m_tuples object.
    
    Args:
        read_1: An AlignedRead instance corresponding to read_1 of the readpair.
        read_2: An AlignedRead instance corresponding to read_2 of the readpair.
        BAM: The Samfile instance corresponding to the sample. Required in order to extract chromosome names from read.
        methylation_m_tuples: A dictionary storing all observed m-tuples of methylation events and their WithinFragmentComethylationMTuple instance.
        m: Is the "m" in "m-tuple", i.e. the size of the m-tuple. m must be an integer greater than or equal to 1. WARNING: No error or warning produced if this condition is violated.
        methylation_type: A string of the methylation type, e.g. CG for CpG methylation. Must be a valid option for the WithinFragmentComethylationMTuple class.
        methylation_pattern: A regular expression of the methylation loci, e.g. '[Zz]' for CpG-methylation
        ignore_start_r1: How many bases to ignore from start (5' end) of read_1.
        ignore_start_r2: How many bases to ignore from start (5' end) of read_2.
        ignore_end_r1: How many bases to ignore from end (3' end) of read_1.
        ignore_end_r2: How many bases to ignore from end (3' end) of read_2.
        min_qual: Ignore bases with quality-score less than this value.
        min_mapq: Ignore reads with mapQ less than this value.
        phred_offset: The offset in the Phred scores. Phred33 corresponds to phred_offset = 33 and Phred64 corresponds to phred_offset 64.
        ob_strand_offset: How many bases a methylation loci on the OB-strand must be moved to the left in order to line up with the C on the OT-strand; e.g. ob_strand_offset = 1 for CpGs.
        overlap_check: The type of check to be performed (listed by most-to-least stringent): check the entire overlapping sequence is identical (sequence), check the XM-tag is identical for the overlapping region (XM), do no check of the overlapping bases but use the read with the higher quality basecalls in the overlapping region (none), or simply use the overlapping bases from read_1 ala bismark_methylation_extractor (bismark)
        n_fragment_skipped_due_to_bad_overlap: The total number of fragments (read-pairs) skipped due to the overlapping sequencing not passing the filter.
    Returns:
        methylation_m_tuples: An updated version of methylation_m_tuples
        n_methylation_loci: The number of methylation loci extracted from the read.
    """
    # Identify methylation events in read, e.g. CpGs or CHHs. The methylation_pattern is specified by a command line argument (e.g. Z/z corresponds to CpG)
    methylation_index_1 = [midx.start() for midx in re.finditer(methylation_pattern, read_1.opt('XM'))]
    methylation_index_2 = [midx.start() for midx in re.finditer(methylation_pattern, read_2.opt('XM'))]
    # Ignore any start or end positions of read if required
    if (ignore_start_r1 > 0) | (ignore_start_r2 > 0):
        methylation_index_1 = ignore_first_n_bases(read_1, methylation_index_1, ignore_start_r1)
        methylation_index_2 = ignore_first_n_bases(read_2, methylation_index_2, ignore_start_r2)
    if (ignore_end_r1 > 0) | (ignore_end_r2 > 0):
        methylation_index_1 = ignore_last_n_bases(read_1, methylation_index_1, ignore_end_r1)
        methylation_index_2 = ignore_last_n_bases(read_2, methylation_index_2, ignore_end_r2)
    # Ignore any positions with a base quality less than  min_qual
    methylation_index_1 = ignore_low_quality_bases(read_1, methylation_index_1, min_qual, phred_offset)
    methylation_index_2 = ignore_low_quality_bases(read_2, methylation_index_2, min_qual, phred_offset)
    # Ignore any reads with mapQ less than min_mapq. Do this by setting methylation_index_1 = [] (in the case of read_1) and methylation_index_2 = [] (in the case of read_2)
    if read_1.mapq < min_mapq:
        methylation_index_1 = []
        warning_msg = ''.join(['Ignoring read_1 of readpair ', read_1.qname, ' since its mapQ < ', str(min_mapq)])
        warnings.warn(warning_msg)
    if read_2.mapq < min_mapq:
        methylation_index_2 = []
        warning_msg = ''.join(['Ignoring read_2 of readpair ', read_2.qname, ' since its mapQ < ', str(min_mapq)])
        warnings.warn(warning_msg)
    # Check for overlapping reads from a readpair.
    # If reads overlap check whether the overlapping sequence passes the filter given by overlap_check.
    # If the overlapping sequence does not pass the filter report a warning, increment a counter and skip the readpair (by setting methylation_index_1 and methylation_index_2 to be the empty list).
    n_overlap = read_1.alen + read_2.alen - abs(read_1.tlen)
    if n_overlap > 0:
        if is_overlapping_sequence_identical(read_1, read_2, n_overlap, overlap_check):
            methylation_index_1, methylation_index_2 = ignore_overlapping_sequence(read_1, read_2, methylation_index_1, methylation_index_2, n_overlap, overlap_check)
        else:
            warning_msg = ''.join(['Skipping readpair ', read.qname, ' as overlapping sequence does not pass filter specified by --overlappingPairedEndFilter ', overlap_check])
            warnings.warn(warning_msg)
            n_fragment_skipped_due_to_bad_overlap += 1
            methylation_index_1 = []
            methylation_index_2 = []
    n_methylation_loci = len(methylation_index_1) + len(methylation_index_2)
    # Only process readpair if there are at least enough CpGs to form one m-tuple.
    if n_methylation_loci >= m:
        positions_1 = [read_1.pos + x + 1 for x in methylation_index_1] # +1 to transform from 0-based to 1-based co-ordinates.
        positions_2 = [read_2.pos + x + 1 for x in methylation_index_2] # +1 to transform from 0-based to 1-based co-ordinates.
        if any(x in positions_1 for x in positions_2):
            exit_msg = ''.join(['ERROR: For readpair ', read.qname, ', position_1 and position_2 contain a common position. This should not happen.'])
            print positions_1
            print positions_2
            sys.exit(exit_msg)
        # Case 1: Readpair aligns to OT-strand
        if read_1.opt('XG') == 'CT' and read_2.opt('XG') == 'CT' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
            # Skip readpair if methylation loci are incorrectly ordered and report a warning.
            if not positions_1 + positions_2 == sorted(positions_1 + positions_2):
                warning_msg = ' '.join(["Skipping paired-end read", read.qname, "as positions aren't properly ordered (Case 1)."])
                warnings.warn(warning_msg)
            else:
                # First, create all m-tuples of methylation loci where each locus is from read_1.
                if len(methylation_index_1) >= m:
                    for i in range(0, len(methylation_index_1) - m + 1): # For a read containing k methylation loci there are (k - m + 1) m-tuples.:
                        this_m_tuple_positions_1 = positions_1[i:(i + m)]
                        # Create a unique ID for each m-tuple of methylation loci (of form "chromosome:position_1-position_2-...-position_m")
                        m_tuple_id = ''.join([BAM.getrname(read_1.tid), ':', '-'.join([str(j) for j in this_m_tuple_positions_1])])
                        # Check whether m-tuple has already been observed. If not, create a WithinFragmentMethylationMTuple instance for it and increment its count. Otherwise, just increment its count.
                        if not m_tuple_id in methylation_m_tuples:
                            methylation_m_tuples[m_tuple_id] = WithinFragmentComethylationMTuple(BAM.getrname(read_1.tid), read_1.tid, m, this_m_tuple_positions_1, methylation_type) # read_1.tid acts as the chromosome_index required by WithinFragmentComethylationMTuple class
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_1.opt('XM')[j] for j in methylation_index_1[i:(i + m)]]), methylation_type, read_1, read_2)
                        else:
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_1.opt('XM')[j] for j in methylation_index_1[i:(i + m)]]), methylation_type, read_1, read_2)
                # Second, create all m-tuples of methylation loci where the leftmost locus is on read_1 and the rightmost locus is on read_2
                num_shared_m_tuples = max(len(methylation_index_1) + len(methylation_index_2) - m + 1, 0) - max(len(methylation_index_1) - m + 1, 0) - max(len(methylation_index_2) - m + 1, 0) # the number of m-tuples that span read_1 and read_2
                leftmost_shared_locus_index = max(0, len(methylation_index_1) - m + 1) # The index of the leftmost locus to be part of a "shared" m-tuple. The rightmost_shared_locus_index = min(m - 2, len(methylation_index_2) - 1), however this is not required
                for i in range(0, num_shared_m_tuples):
                    this_m_tuple_positions_1 = positions_1[(leftmost_shared_locus_index + i):]
                    this_m_tuple_positions_2 = positions_2[:(m - len(this_m_tuple_positions_1))]
                    # EXTRA CHECK: Skip readpair if methylation loci are incorrectly ordered and report a warning. This has already been checked a few lines above so this is a sanity check.
                    if not this_m_tuple_positions_1 + this_m_tuple_positions_2 == sorted(this_m_tuple_positions_1 + this_m_tuple_positions_2):
                        warning_msg = ' '.join(["Skipping paired-end read", read.qname, "as positions aren't properly ordered (Case 1: shared m-tuples)."])
                        warnings.warn(warning_msg)
                    else:
                        # Create a unique ID for each m-tuple of methylation loci (of form "chromosome:position_1-position_2-...-position_m")
                        m_tuple_id = ''.join([BAM.getrname(read_1.tid), ':', '-'.join([str(j) for j in this_m_tuple_positions_1] + [str(k) for k in this_m_tuple_positions_2])])
                    # Check whether m-tuple has already been observed. If not, create a WithinFragmentMethylationMTuple instance for it and increment its count. Otherwise, just increment its count.
                        if not m_tuple_id in methylation_m_tuples:
                            methylation_m_tuples[m_tuple_id] = WithinFragmentComethylationMTuple(BAM.getrname(read_1.tid), read_1.tid, m, this_m_tuple_positions_1 + this_m_tuple_positions_2, methylation_type) # read_1.tid acts as the chromosome_index required by WithinFragmentComethylationMTuple class
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_1.opt('XM')[j] for j in methylation_index_1[(leftmost_shared_locus_index + i):]] + [read_2.opt('XM')[j] for j in methylation_index_2[:(m - len(this_m_tuple_positions_1))]]), methylation_type, read_1, read_2)
                        else:
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_1.opt('XM')[j] for j in methylation_index_1[(leftmost_shared_locus_index + i):]] + [read_2.opt('XM')[j] for j in methylation_index_2[:(m - len(this_m_tuple_positions_1))]]), methylation_type, read_1, read_2)
                # Finally, create all m-tuples of methylation loci where each locus is from read_2.        
                if len(methylation_index_2) >= m:
                    for i in range(0, len(methylation_index_2) - m + 1): # For a read containing k methylation loci there are (k - m + 1) m-tuples.:
                        this_m_tuple_positions_2 = positions_2[i:(i + m)]
                        # Create a unique ID for each m-tuple of methylation loci (of form "chromosome:position_1-position_2-...-position_m")
                        m_tuple_id = ''.join([BAM.getrname(read_2.tid), ':', '-'.join([str(j) for j in this_m_tuple_positions_2])])
                        # Check whether m-tuple has already been observed. If not, create a WithinFragmentMethylationMTuple instance for it and increment its count.
                        if not m_tuple_id in methylation_m_tuples:
                            methylation_m_tuples[m_tuple_id] = WithinFragmentComethylationMTuple(BAM.getrname(read_2.tid), read_2.tid, m, this_m_tuple_positions_2, methylation_type) # read_2.tid acts as the chromosome_index required by WithinFragmentComethylationMTuple class
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_2.opt('XM')[j] for j in methylation_index_2[i:(i + m)]]), methylation_type, read_1, read_2)
                        else:
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_2.opt('XM')[j] for j in methylation_index_2[i:(i + m)]]), methylation_type, read_1, read_2)
        # Case 2: Readpair aligns to OB-strand
        elif read_1.opt('XG') == 'GA' and read_2.opt('XG') == 'GA' and read_1.opt('XR') == 'CT' and read_2.opt('XR') == 'GA':
            # Translate co-ordinates "ob_strand_offset" bases to the left so that it points to the C on the OT-strand of the methylation locus
            positions_1 = [x - ob_strand_offset for x in positions_1]
            positions_2 = [x - ob_strand_offset for x in positions_2]
            # Skip readpair if methylation loci are incorrectly ordered and report a warning.
            if not positions_2 + positions_1 == sorted(positions_2 + positions_1): 
                warning_msg = ' '.join(["Skipping paired-end read", read.qname, "as positions aren't properly ordered (Case 2)."])
                warnings.warn(warning_msg)
            else:
                # First, create all m-tuples of methylation loci where each locus is from read_1.
                if len(methylation_index_1) >= m:
                    for i in range(0, len(methylation_index_1) - m + 1): # For a read containing m methylation loci there are (m - m-tuple + 1) m-tuples.:
                        this_m_tuple_positions_1 = positions_1[i:(i + m)]
                        # Create a unique ID for each m-tuple of methylation loci (of form "chromosome:position_1-position_2-...-position_m")
                        m_tuple_id = ''.join([BAM.getrname(read_1.tid), ':', '-'.join([str(j) for j in this_m_tuple_positions_1])])
                        # Check whether m-tuple has already been observed. If not, create a WithinFragmentMethylationMTuple instance for it and increment its count.
                        if not m_tuple_id in methylation_m_tuples:
                            methylation_m_tuples[m_tuple_id] = WithinFragmentComethylationMTuple(BAM.getrname(read_1.tid), read_1.tid, m, this_m_tuple_positions_1, methylation_type) # read_1.tid acts as the chromosome_index required by WithinFragmentComethylationMTuple class
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_1.opt('XM')[j] for j in methylation_index_1[i:(i + m)]]), methylation_type, read_1, read_2)
                        else:
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_1.opt('XM')[j] for j in methylation_index_1[i:(i + m)]]), methylation_type, read_1, read_2)
                # Second, create all m-tuples of methylation loci where the leftmost locus is on read_1 and the rightmost locus is on read_2
                num_shared_m_tuples = max(len(methylation_index_1) + len(methylation_index_2) - m + 1, 0) - max(len(methylation_index_1) - m + 1, 0) - max(len(methylation_index_2) - m + 1, 0) # the number of m-tuples that span read_1 and read_2
                leftmost_shared_locus_index = max(0, len(methylation_index_2) - m + 1) # The index of the leftmost locus to be part of a "shared" m-tuple. The rightmost_shared_locus_index = min(m - 2, len(methylation_index_1) - 1), however this is not required (m - 2 = m - 1 - 1, because Python lists are 0-indexed)
                for i in range(0, num_shared_m_tuples):
                    this_m_tuple_positions_2 = positions_2[(leftmost_shared_locus_index + i):]
                    this_m_tuple_positions_1 = positions_1[:(m - len(this_m_tuple_positions_2))]
                    # EXTRA CHECK: Skip readpair if methylation loci are incorrectly ordered and report a warning. This has already been checked a few lines above so this is a sanity check.
                    if not this_m_tuple_positions_2 + this_m_tuple_positions_1 == sorted(this_m_tuple_positions_2 + this_m_tuple_positions_1):
                        warning_msg = ' '.join(["Skipping paired-end read", read.qname, "as positions aren't properly ordered (Case 2: shared m-tuples)."])
                        warnings.warn(warning_msg)
                    else:
                        # Create a unique ID for each m-tuple of methylation loci (of form "chromosome:position_1-position_2-...-position_m")
                        m_tuple_id = ''.join([BAM.getrname(read_1.tid), ':', '-'.join([str(j) for j in this_m_tuple_positions_2] + [str(k) for k in this_m_tuple_positions_1])])
                    # Check whether m-tuple has already been observed. If not, create a WithinFragmentMethylationMTuple instance for it and increment its count.
                        if not m_tuple_id in methylation_m_tuples:
                            methylation_m_tuples[m_tuple_id] = WithinFragmentComethylationMTuple(BAM.getrname(read_1.tid), read_1.tid, m, this_m_tuple_positions_2 + this_m_tuple_positions_1, methylation_type) # read_1.tid acts as the chromosome_index required by WithinFragmentComethylationMTuple class
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_2.opt('XM')[j] for j in methylation_index_2[(leftmost_shared_locus_index + i):]] + [read_1.opt('XM')[j] for j in methylation_index_1[:(m - len(this_m_tuple_positions_2))]]), methylation_type, read_1, read_2)
                        else:
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_2.opt('XM')[j] for j in methylation_index_2[(leftmost_shared_locus_index + i):]] + [read_1.opt('XM')[j] for j in methylation_index_1[:(m - len(this_m_tuple_positions_2))]]), methylation_type, read_1, read_2)
                # Finally, create all m-tuples of methylation loci where each locus is from read_2.        
                if len(methylation_index_2) >= m:
                    for i in range(0, len(methylation_index_2) - m + 1): # For a read containing m methylation loci there are (m - m-tuple + 1) m-tuples.:
                        this_m_tuple_positions_2 = positions_2[i:(i + m)]
                        # Create a unique ID for each m-tuple of methylation loci (of form "chromosome:position_1-position_2-...-position_m")
                        m_tuple_id = ''.join([BAM.getrname(read_2.tid), ':', '-'.join([str(j) for j in this_m_tuple_positions_2])])
                        # Check whether m-tuple has already been observed. If not, create a WithinFragmentMethylationMTuple instance for it and increment its count.
                        if not m_tuple_id in methylation_m_tuples:
                            methylation_m_tuples[m_tuple_id] = WithinFragmentComethylationMTuple(BAM.getrname(read_2.tid), read_2.tid, m, this_m_tuple_positions_2, methylation_type) # read_2.tid acts as the chromosome_index required by WithinFragmentComethylationMTuple class
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_2.opt('XM')[j] for j in methylation_index_2[i:(i + m)]]), methylation_type, read_1, read_2)
                        else:
                            methylation_m_tuples[m_tuple_id].increment_count(''.join([read_2.opt('XM')[j] for j in methylation_index_2[i:(i + m)]]), methylation_type, read_1, read_2)
    return methylation_m_tuples, n_methylation_loci, n_fragment_skipped_due_to_bad_overlap
                                    
# tab_writer writes a tab-separated output file to the filehandle OUT
tab_writer = csv.writer(OUT, delimiter='\t', quotechar=' ', quoting=csv.QUOTE_MINIMAL)

def write_methylation_m_tuples_to_file(methylation_m_tuples, m):
    """Write the methylation_m_tuples instance to a tab-separated file. The m-tuples are ordered by chromosome and genomic co-ordinates.
    
    Args:
        methylation_m_tuples: A dictionary storing all observed m-tuples of methylation events and their WithinFragmentComethylationMTuple instance. 
    """
    # Create the header row
    header = ['chr'] + ['pos' + str(i) for i in range(1, m + 1)]
    example_row = WithinFragmentComethylationMTuple('chr1', 1, m, [0] * m, 'CG').counts
    for key in sorted(example_row.iterkeys()):
        header.append(key)
    # Write the header to file
    tab_writer.writerow(header)
    # Write each m-tuple of methylation loci to file using a nested for-loop
    # (1) Loop over chromosomes by increasing chromosome_index order
    # (2) Loop over positions by increasing order
    for this_m_tuple in sorted(methylation_m_tuples.values(), key = attrgetter('chromosome_index', 'positions')):
        this_m_tuple_ordered_counts = []
        for i in sorted(this_m_tuple.counts.iterkeys()):
            this_m_tuple_ordered_counts.append(this_m_tuple.counts[i])
        row = [this_m_tuple.chromosome] + this_m_tuple.positions + this_m_tuple_ordered_counts
        tab_writer.writerow(row)
    
#### Variable initialisations ####
# Set the Phred quality score offset
if args.phred64:
    phred_offset = 64
else:
    phred_offset = 33
# Set the "m" in "m-tuple", i.e. the size of the methylation-loci m-tuples
m = args.mTuple
# Set the methylation type to be used in the analysis
methylation_type = args.methylationType
if methylation_type == 'CG':
    methylation_pattern = re.compile(r'[Zz]')
    if args.strandSpecific:
        ob_strand_offset = 0
    else:
        ob_strand_offset = 1
elif methylation_type == 'CHG':
    methylation_pattern = re.compile(r'[Xx]')
    if args.strandSpecific:
        ob_strand_offset = 0
    else:
        ob_strand_offset = 2
elif methylation_type == 'CHH':
    methylation_pattern = re.compile(r'[Hh]')
    if args.strandSpecific:
        ob_strand_offset = 0
    else:
        exit_msg = 'CHH-methylation is not strand-symmetric and thus the --strandSpecific option must be specified.'
        sys.exit(exit_msg)
else:
    sys.exit("--methylationType must be one of 'CG', 'CHG' or 'CHH'")
    
overlap_check = args.overlappingPairedEndFilter
ignore_start_r1 = args.ignoreStart_r1
ignore_start_r2 = args.ignoreStart_r2
ignore_end_r1 = args.ignoreEnd_r1
ignore_end_r2 = args.ignoreEnd_r2
min_qual = args.minQual
min_mapq = args.minMapQ

n_fragment = 0 # The number of DNA fragments. One single-end read contributes one to the count and each half of a readpair contributes half a count.
n_fragment_skipped_due_to_bad_overlap = 0 # The number of DNA fragments (read-pairs) skipped due to the overlapping sequencing not passing the appropriate filter
n_methylation_loci_per_read = {} # Dictionary of the number of methylation loci that passed QC per read
methylation_m_tuples = {} # Dictionary of m-tuples of methylation loci with keys of form chromosome:position_1:position_2 and values corresponding to a WithinFragmentComethylationMTuple instance

#### The main program. Loops over the BAM file line-by-line (i.e. alignedRead-by-alignedRead) and extracts the XM information for each read or readpair. ####
# Print key variable names and command line parameter options to STDOUT
print 'Input file =', BAM.filename
print 'Output file =', OUT.name
warning_msg = 'methylation m-tuples may have intervening methylation events (i.e. NIC > 0). These generally occur in paired-end reads with non-overlapping mates but can also be caused by filtering methylation calls by base quality, read-position, etc. These should be post-hoc filtered.'
warnings.warn(warning_msg)
if (m < 1) or (m != floor(m)):
    exit_msg = "ERROR: --mTuple must be an integer greater than or equal to 1."
    sys.exit(exit_msg)
if args.oldBismark:
    print 'Assuming file is a paired-end SAM/BAM created with Bismark version < 0.8.3'
if args.ignoreDuplicates:
    print 'Ignoring reads marked as PCR duplicates'
if args.ignoreImproperPairs:
    print 'Ignoring improper readpairs'
print 'Assuming quality scores are Phred', phred_offset
print "Ignoring", ignore_start_r1, "bp from 5' end of each read if data are single-end or of each read_1 if data are paired end"
print "Ignoring", ignore_start_r2, "bp from 5' end of each read_2 if data are paired end"
print "Ignoring", ignore_end_r1, "bp from 3' end of each read if data are single-end or of each read_1 if data are paired end"
print "Ignoring", ignore_end_r2 , "bp from 3' end of each read_2 if data are paired end"
print 'Ignoring methylation calls with base-quality less than', min_qual
print 'Ignoring reads with mapQ less than', min_mapq
print 'Analysing', methylation_type, 'methylation loci'
print ''.join(['Creating bookended ', str(m), '-tuples of methylation loci'])
if overlap_check == 'sequence':
    print 'Paired-end reads that have overlapping mates will be filtered out if the overlapping sequences are not identical'
elif overlap_check == 'XM':
    print 'Paired-end reads that have overlapping mates will be filtered out if the XM-tags for the overlapping sequence are not identical'
elif overlap_check == 'bismark':
    print "Paired-end reads that have overlapping mates will simply use the overlapping bases from read_1 ala bismark_methylation_extractor"
elif overlap_check == 'none':
    print 'Paired-end reads that have overlapping mates will not be subject to any filtering based on the overlapping sequence'
else:
    exit_msg = "ERROR: --overlappingPairedEndFilter must be one of 'sequence', 'XM', 'bismark' or 'none'"
    sys.exit(exit_msg)

# Check that mapped reads have the XR-, XG- and XM-tags set. Will only check first mapped read, so assumes that the first mapped read in the BAM is representative of all mapped reads in the BAM.
print 'Checking that the XR-, XG- and XM-tags are set for the first mapped read...'
for read in BAM:
    if read.is_unmapped:
        continue
    # Check XR-tag
    if not 'XR' in [x[0] for x in read.tags]:
        exit_msg = "ERROR: The first mapped read does not contain an XR-tag. The XR-tag stores the read conversion state for the alignment and is required by comethylation.py.\n SAM/BAM files created by Bismark should already have the XR-tag set.\n If your SAM/BAM was created with another program you will need to add the correct XR-tags before proceeding. The script bismarkify.py may be able to help you with this."
        sys.exit(exit_msg)
    # Check XG-tag
    if not 'XG' in [x[0] for x in read.tags]:
        exit_msg = "ERROR: The first mapped read does not contain an XG-tag. The XG-tag stores the read conversion state for the alignment and is required by comethylation.py.\n SAM/BAM files created by Bismark should already have the XG-tag set.\n If your SAM/BAM was created with another program you will need to add the correct XG-tags before proceeding. The script bismarkify.py may be able to help you with this."
        sys.exit(exit_msg)
    # Check XG-tag
    if not 'XM' in [x[0] for x in read.tags]:
        exit_msg = "ERROR: The first mapped read does not contain an XM-tag. The XMtag stores the methylation call string for the alignment and is required by comethylation.py.\n SAM/BAM files created by Bismark should already have the XM-tag set.\n If your SAM/BAM was created with another program you will need to add the correct XM-tags before proceeding. The script bismarkify.py may be able to help you with this."
        sys.exit(exit_msg)
    else:
        print 'Verified that the XR-, XG- and XM-tags are set for the first mapped read'
        # Reset BAM to start
        BAM.reset()
        break

# Loop over the BAM and extract methylation m-tuples
for read in BAM:
    # Read is first in a read-pair
    if read.is_paired and read.is_read1:
        # Fix QNAME and FLAG values if --oldBismark flag is set
        if(args.oldBismark):
            read = fix_old_bismark(read)
        read_1 = read
        continue
    # Read is second in a read-pair
    elif read.is_paired and read.is_read2:
        # Fix QNAME and FLAG values if --oldBismark flag is set
        if(args.oldBismark):
            read = fix_old_bismark(read)
        read_2 = read
        n_fragment += 1
        # Skip duplicates reads if command line parameter --ignoreDuplicates is set
        if args.ignoreDuplicates and read.is_duplicate:
            continue
        # Skip read if either mate is unmapped
        if read_1.is_unmapped or read_2.is_unmapped:
            continue
        # Skip improperly paired-reads if command line parameter --ignoreImproperPairs is set
        if args.ignoreImproperPairs and not read.is_proper_pair:
            warning_msg = ''.join(['Skipping read-pair ', read_1.qname, ' as it is not properly paired.'])
            warnings.warn(warning_msg)
            continue
        # Skip reads containing indels
        if does_read_contain_indel(read_1) or does_read_contain_indel(read_2):
            continue
        # Check that read_1 and read_2 are aligned to the same chromosome and have identical read-names.
        # If not, skip the readpair.
        if read_1.tid == read_2.tid and read_1.qname == read_2.qname:
            methylation_m_tuples, n_methylation_loci_in_fragment, n_fragment_skipped_due_to_bad_overlap = extract_and_update_methylation_index_from_paired_end_reads(read_1, read_2, BAM, methylation_m_tuples, m, methylation_type, methylation_pattern, ignore_start_r1, ignore_start_r2, ignore_end_r1, ignore_end_r2, min_qual, min_mapq, phred_offset, ob_strand_offset, overlap_check, n_fragment_skipped_due_to_bad_overlap)
            # Update the n_methylation_loci_per_read dictionary
            if not n_methylation_loci_in_fragment in n_methylation_loci_per_read:
                n_methylation_loci_per_read[n_methylation_loci_in_fragment] = 0
            n_methylation_loci_per_read[n_methylation_loci_in_fragment] += 1
        elif read_1.tid != read_2.tid:
            warning_msg = ''.join(['Skipping readpair', read_1.qname, ' as reads aligned to different chromosomes (', BAM.getrname(read_1.tid), ' and ', BAM.getrname(read_2.tid), ')'])
            warnings.warn(warning_msg)
            continue
        elif read_1.qname != read_2.qname:
            exit_msg = "ERROR: The name of read_1 is not identical to to that of read_2 for read-pair ", read_1.qname, read_2.qname, ". Please sort your paired-end BAM file in queryname order with Picard's SortSam function."
            sys.exit(exit_msg)
        # Set both read_1 and read_2 as the None object to ensure that old values don't accidentally carry over to when I process the next read-pair
        read_1 = None
        read_2 = None
    # Read is single-end
    elif not read.is_paired:
        n_fragment += 1
        # Skip duplicates reads if command line parameter --ignoreDuplicates is set
        if args.ignoreDuplicates and read.is_duplicate:
            continue
        # Skip read if it is unmapped
        if read.is_unmapped:
            continue
        # Skip reads containing indels
        if does_read_contain_indel(read):
            continue
        methylation_m_tuples, n_methylation_loci_in_fragment = extract_and_update_methylation_index_from_single_end_read(read, BAM, methylation_m_tuples, m, methylation_type, methylation_pattern, ignore_start_r1, ignore_end_r1, min_qual, min_mapq, phred_offset, ob_strand_offset)
        if not n_methylation_loci_in_fragment in n_methylation_loci_per_read:
            n_methylation_loci_per_read[n_methylation_loci_in_fragment] = 0
        n_methylation_loci_per_read[n_methylation_loci_in_fragment] += 1
    # Read is neither single-end or a mate from a read-pair. This is odd and shouldn't happen.
    else:
        exit_msg = ''.join(["Read is neither a single-end read nor part of a paired-end read. Check the SAM FLAG values are correctly set for read:", read.qname])
        sys.exit(exit_msg)
        continue

# Write results to disk
print 'Writing output to', OUT.name, '...'
write_methylation_m_tuples_to_file(methylation_m_tuples, m)

# Print some summary information to HIST and STDOUT
print 'Number of DNA fragments in file:', int(n_fragment)
print 'Number of DNA fragments (read-pairs) skipped due to overlapping sequence not passing QC filter:', int(n_fragment_skipped_due_to_bad_overlap)
n_informative_fragments = 0
for k, v in n_methylation_loci_per_read.iteritems():
    if k >= m:
        n_informative_fragments += v
print ''.join(['Number of reads or readpairs informative for co-methylation ', str(m), '-tuples = ', str(n_informative_fragments), ' (', str(round(n_informative_fragments / float(n_fragment) * 100, 1)), '% of total fragments)'])
print 'Writing histogram of number of', args.methylationType, 'methylation loci per DNA fragment that passed QC filters to', HIST.name, '...'
HIST.write('n\tcount\n')
for k, v in iter(sorted(n_methylation_loci_per_read.iteritems())):
    HIST.write(''.join([str(k), '\t', str(v), '\n']))

# Close all files
BAM.close()
OUT.close()
HIST.close()

