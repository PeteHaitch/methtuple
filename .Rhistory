legend.position = "right",
legend.text.align = NA,
legend.title.align = NA,
legend.direction = "vertical",
legend.box = NA,
panel.background = theme_rect(fill = "black", colour = NA),
panel.border = theme_rect(fill = NA, colour = "white"),
panel.grid.major = theme_line(colour = "grey20", size = 0.2),
panel.grid.minor = theme_line(colour = "grey5", size = 0.5),
panel.margin = unit(0.25, "lines"),
strip.background = theme_rect(fill = "grey30", colour = "grey10"),
strip.text.x = theme_text(size = base_size * 0.8, colour = 'white'),
strip.text.y = theme_text(size = base_size * 0.8, colour = 'white', angle = -90),
plot.background = theme_rect(colour = 'black', fill = 'black'),
plot.title = theme_text(size = base_size * 1.2),
plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")
), class = "options")
}
mdf <- data.frame(x <- seq(0, 10), y=rnorm(x),
f=factor(rep(letters[1:2], each=3, length=length(x))))
## test with facets
## p <- qplot(x, y, data=mdf, colour=f, geom=c("line", "point"), facets=f~.)
p <- qplot(x, y, data=mdf, colour=f, geom=c("line", "point")) +
scale_x_continuous(expand=c(0,0))+
scale_y_continuous(expand=c(0,0))
all.themes <- lapply(themes.list, function(.t) {
gTree(children=gList(ggplotGrob(p + get(.t)()),
rectGrob(),
textGrob(bquote(italic(.(.t))),
y=1, vjust=1.2, gp=gpar(col="grey"))))
})
library(gridExtra)
library(imguR)
imguR(width=8, height=16)
do.call(grid.arrange, c(all.themes, list(ncol=2)))
unit(0.3, "lines")
theme_blank()
axis.line = theme_blank(),
base_size <- 12
theme_text(size = base_size * 0.8, colour = 'white', lineheight = 0.9, vjust = 1)
theme_text(size = base_size * 0.8, colour = 'white', lineheight = 0.9, hjust = 1)
theme_segment(colour = "white", size = 0.2)
theme_text(size = base_size, colour = 'white', vjust = 1)
theme_text(size = base_size, colour = 'white', angle = 90, vjust = 0.5)
unit(0.3, "lines")
unit(0.5, "lines")
theme_rect(colour = NA)
theme_rect(colour = "white", fill = 'black')
unit(1.2, "lines")
structure(list(
axis.line = theme_blank(),
axis.text.x = theme_text(size = base_size * 0.8, colour = 'white', lineheight = 0.9, vjust = 1),
axis.text.y = theme_text(size = base_size * 0.8, colour = 'white', lineheight = 0.9, hjust = 1),
axis.ticks = theme_segment(colour = "white", size = 0.2),
axis.title.x = theme_text(size = base_size, colour = 'white', vjust = 1),
axis.title.y = theme_text(size = base_size, colour = 'white', angle = 90, vjust = 0.5),
axis.ticks.length = unit(0.3, "lines"),
axis.ticks.margin = unit(0.5, "lines"),
legend.background = theme_rect(colour = NA),
legend.key = theme_rect(colour = "white", fill = 'black'),
legend.key.size = unit(1.2, "lines"),
legend.key.height = NA,
legend.key.width = NA,
legend.text = theme_text(size = base_size * 0.8, colour = 'white'),
legend.title = theme_text(size = base_size * 0.8, face = "bold", hjust = 0, colour = 'white'),
legend.position = "right",
legend.text.align = NA,
legend.title.align = NA,
legend.direction = "vertical",
legend.box = NA,
panel.background = theme_rect(fill = "black", colour = NA),
panel.border = theme_rect(fill = NA, colour = "white"),
panel.grid.major = theme_line(colour = "grey20", size = 0.2),
panel.grid.minor = theme_line(colour = "grey5", size = 0.5),
panel.margin = unit(0.25, "lines"),
strip.background = theme_rect(fill = "grey30", colour = "grey10"),
strip.text.x = theme_text(size = base_size * 0.8, colour = 'white'),
strip.text.y = theme_text(size = base_size * 0.8, colour = 'white', angle = -90),
plot.background = theme_rect(colour = 'black', fill = 'black'),
plot.title = theme_text(size = base_size * 1.2),
plot.margin = unit(c(1, 1, 0.5, 0.5), "lines")
), class = "options")
theme_blac()
theme_black()
qplot(1:10) + theme_black()
citation(ggplot2)
citation('ggplot2')
?theme_text
set.seed(101)
n <- 50000
X <- mvrnorm(n, mu=c(.5,2.5), Sigma=matrix(c(1,.6,.6,1), ncol=2))
# Generate some data
library(MASS)
set.seed(101)
n <- 50000
X <- mvrnorm(n, mu=c(.5,2.5), Sigma=matrix(c(1,.6,.6,1), ncol=2))
head(X)
smoothScatter(X)
?smoothScatter
plot(1:10, col = 'darkgrey')
library(gviz)
source('http://bioconductor.org/biocLite.R')
biocLite('gviz')
biocLite('Gviz')
biocLite(character(), ask=FALSE)
library(GenomicRanges)
stop('Error: Sorry, lor does not yet support strand-specific log odds ratios.')
stop('Sorry, lor does not yet support strand-specific log odds ratios.')
stop('Sorry, lor does not yet support strand-specific log odds ratios. Please use strand = 'combined''')
stop('Sorry, lor does not yet support strand-specific log odds ratios. Please use strand = 'combined')
stop('Sorry, lor does not yet support strand-specific log odds ratios. Please use strand = \'combined\'')
setClass("bloop", contains = "GRanges", representation='character')
showClass('bloop')
showClass("GRanges")
setClass("bloop", contains = "GRanges", representation='DataFrame')
setClass("bloop", contains = "GRanges", representation='data.frame')
showClass(bloop)
showClass('bloop')
setClass("bloop", contains = "GRanges", representation(blonko ='data.frame')
setClass("bloop", contains = "GRanges", representation(blonko ='data.frame'))
showClass('bloop')
tmp <- function(seqnames='chr2', ranges = IRanges(start = 2, end = 6), blonko = data.frame(x = 2, y = 6))
bloop <- function(seqnames, ranges, blonko){
new("bloop", GRanges(seqnames, ranges),
blonko = blonko)
}
bloop('chr2', IRanges(start = 2, width = 5), blonko = data.frame(x = 5, y = 12))
a <- bloop('chr2', IRanges(start = 2, width = 5), blonko = data.frame(x = 5, y = 12))
a
str(a)
a@blonko
width(a)
class(a)
slotNames(a)
showClass(a)
showClass('bloop')
slot(a)
slotNames(a)
a@metadata
bloop <- function(seqnames, ranges, blonko){
new("bloop", GRanges(seqnames, ranges, metadata),
blonko = blonko)
}
a <- bloop(seqnames = 'chr2', ranges = IRanges(start = 2, width = 5), blonko = data.frame(x = 5, y = 12), metadata = 'The sample name')
bloop <- function(seqnames, ranges, blonko){
new("bloop", GRanges(seqnames, ranges, metadata),
blonko = blonko)
}
a <- bloop(seqnames = 'chr2', ranges = IRanges(start = 2, width = 5), metadata = list('The sample name'), blonko = data.frame(x = 5, y = 12))
a
rm(a)
?GRanges
bloop <- function(seqnames, ranges, blonko){
new("bloop", GRanges(seqnames, ranges),
blonko = blonko)
}
a <- bloop(seqnames = 'chr2', ranges = IRanges(start = 2, width = 5), blonko = data.frame(x = 5, y = 12))
a
a@blonko
a@M
?quantile
library(ggplot2)
?ggtitle
?qplot
library(Rcpp)
library(inline)
fx <- cxxfunction(signature( x = "numeric" ), 'NumericVector xx(x);
return wrap( std::accumulate( xx.begin(), xx.end(), 0.0));',
plugin = "Rcpp")
Sys.setenv(R_ARCH="/x86_64")
Sys.setenv()
Sys.getenv()
library(Rcpp)
library(inline)
fx <- cxxfunction(signature( x = "numeric" ), 'NumericVector xx(x);
return wrap( std::accumulate( xx.begin(), xx.end(), 0.0));',
plugin = "Rcpp")
res <- fx( seq( 1, 10, by = 0.5 ) )
res
library(GenomicRanges)
?DataF
?DataFrame
?shift
?shiftApply
m <- ggplot(movies, aes(x=rating, y=length)) + geom_point() + scale_y_continuous(
+ limits=c(1, 500))
library(ggplot2)
m <- ggplot(movies, aes(x=rating, y=length)) + geom_point() + scale_y_continuous(
+ limits=c(1, 500))
m <- ggplot(movies, aes(x=rating, y=length)) + geom_point() + scale_y_continuous()+ limits=c(1, 500))
m <- ggplot(movies, aes(x=rating, y=length)) + geom_point() + scale_y_continuous(limits=c(1, 500))
m
m <- ggplot(movies, aes(x=rating, y=length)) + scale_y_continuous(limits=c(1, 500))
m + stat_density2d(aes(fill = ..level..), geom="polygon")
?require
sample.name <- 'bloop'
min.cov <- 10
plot(main = expression(paste0(sample.name, ': min.cov ', >=, min.cov))
plot(main = expression(paste0(sample.name, ': min.cov ', >, min.cov))
plot(main = expression(paste0(sample.name, ': min.cov >=', min.cov))
plot(main = expression(paste0(sample.name, ': min.cov >=', min.cov)))
plot(1:10, main = expression(paste0(sample.name, ': min.cov >=', min.cov)))
plot(1:10, main = substitute(paste0(sample.name, ': min.cov >= ', min.cov), list(min.cov = min.cov)))
plot(1:10, main = substitute(paste(sample.name, ': min.cov >= ', min.cov), list(min.cov = min.cov)))
plot(1:10, main = substitute(paste(sample.name,": ", gamma, sep = ""), list(sample.name = sample.name)))
plot(1:10, substitute(paste0(sample.name,": ", gamma), list(sample.name = sample.name)))
plot(1:10, main = substitute(paste0(sample.name,": ", gamma), list(sample.name = sample.name)))
plot(1:10, main = substitute(paste(sample.name, ': min.cov >= ', min.cov, sep = ''), list(min.cov = min.cov)))
plot(1:10, main = substitute(paste(sample.name,": ", gamma, sep = ''), list(sample.name = sample.name)))
plot(1, main = substitute(paste(sample.name, ': min.cov >= ', min.cov, sep = ''), list(min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov >= ', min.cov, sep = ''), list(sample.name = sample.name min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov >= ', min.cov, sep = ''), list(sample.name = sample.name, min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov', >=,  min.cov, sep = ''), list(sample.name = sample.name, min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov', >,  min.cov, sep = ''), list(sample.name = sample.name, min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov', '>=',  min.cov, sep = ''), list(sample.name = sample.name, min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov ', '>=',  min.cov, sep = ''), list(sample.name = sample.name, min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov = ', min.cov, sep = ''), list(sample.name = sample.name min.cov = min.cov)))
plot(1, main = substitute(paste(sample.name, ': min.cov = ', min.cov, sep = ''), list(sample.name = sample.name, min.cov = min.cov)))
load("/Users/hickey/Downloads/lengths.Rdata")
l <- ggplot(length.gg, aes(length, size = year))
l
l + geom_density(size=2) + scale_colour_grey() + labs(colour="Year")
length.gg
qplot(color, data = diamonds, geom = "bar")
qplot(color, data = diamonds, geom = "bar", weight = carat) +
scale_y_continuous("carat")
?scale_colour_discrete
?theme
?element_text
?labs
?theme
?load
?call
?source
# Peter Hickey
# 10/09/2012
# Plots of within-fragment comethylation
# This is version 2 and is a substantial re-write of the existing code.
#### TODOs ####
# Improve quantile plot titles to explicitly include what type of CpG-pairs are being shown - e.g. neighbours or not
# Density plots of all lors at a given IPD.
# Add faceting to quantile plots based on CpG-density and average methylation level in region
#### ggplot2 plot options ####
presentation.theme <- theme(axis.text = element_text(size = 25, colour = 'black'), axis.title.x = element_text(size = 30), axis.title.y = element_text(size = 30, angle = 90, vjust = 0.4), strip.text.x = element_text(size = 25, face = 'italic'), strip.text.y = element_text(size = 25, angle = 270, face = 'italic'), plot.title = element_text(size = 35, face = 'bold'), legend.text = element_text(size = 20), legend.title = element_text(size = 25, face = 'bold'))
#### Function definitions ####
#' read.wf reads in a .wf file (generated by comethylation.py) and stores the result as a GRanges instance.
#'
#' @param sample.name is the name of the sample and should be the prefix of the .wf files
#' @param chromosomes determines for which chromosomes the .wf files are read in. chromosome.names is either a vector of chromosome names or the string "all" in which case all chromosomes except chrM are used (chrM is circular and breaks subsequent calls to findOverlaps).
#' @param pair.choice is 'all' or 'outermost' and determines which type of .wf files are read in.
#' @return a GRanges instance of CpG-pairs containing all .wf files as specified by the command line arguments
#' @keywords WF
#' @export
#' @examples
#' NULL
read.wf <- function(sample.name, chromosomes = 'all', pair.choice = 'all'){
# Construct a list of chromosome names that are to have lag-correlations computed.
if(chromosomes == 'all'){
chromosome.list <- list('chr1', 'chr2', 'chr3', 'chr4', 'chr5', 'chr6', 'chr7', 'chr8', 'chr9', 'chr10', 'chr11', 'chr12', 'chr13',
'chr14', 'chr15', 'chr16', 'chr17', 'chr18', 'chr19', 'chr20', 'chr21', 'chr22', 'chrX', 'chrY')
names(chromosome.list) <- chromosome.list
} else{
chromosome.list <- list(chromosomes)
names(chromosome.list) <- chromosomes
}
wf.files <- list()
for(chrom in names(chromosome.list)){
if(pair.choice == 'all'){
filename <- str_c(sample.name, '_', chrom, '.wf')
} else if(pairChoice == 'outermost'){
filename <- str_c(sample.name, '_', chrom, '_outermost.wf')
}
wf.files[[chrom]] <- read.table(filename, sep = '\t', stringsAsFactors = FALSE, header = TRUE)
}
wf.df <- rbind.fill(WF.files)
wf.gr <- GRanges(seqnames = wf.df$chr, ranges = IRanges(start = wf.df$pos1, end = wf.df$pos2), counts = DataFrame(wf.df[, 4:15]))
names(values(wf.gr)) <- str_sub(names(values(wf.gr)), 8)
seqlengths(wf.gr)[names(chromosome.list)] <- seqlengths(Hsapiens)[names(chromosome.list)]
return(wf.gr)
}
#' lor computes the log odds ratio from an object returned by read.wf. Each CpG-pair gets assigned a log odds ratio (lor) and an asymptotic standard error (ase)
#'
#' @param x is a data.frame created by coercing the DataFrame of MM, MU, UM and UU counts from the WF object to a data.frame
#' @param correct is TRUE or FALSE. Should the counts be "continuity corrected", i.e. add 0.5 to each count?
#'
#' @return a data.frame of log odds ratios and their associated standard errors. Each row corresponds to the same row as the input.
#' @keywords lor
#' @export
#' @examples
#' NULL
lor <- function(x, correct = TRUE){
if(correct){
lor <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, log(x$MM + 0.5) + log(x$UU + 0.5) - log(x$MU + 0.5) - log(x$UM + 0.5))
ase <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, sqrt(1 / (x$MM + 0.5) + 1 / (x$MU + 0.5) + 1 / (x$UM + 0.5) + 1 / (x$MU + 0.5)))
} else{
lor <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, log(x$MM) + log(x$UU) - log(x$MU) - log(x$UM))
ase <- ifelse(x$MM == 0 & x$MU == 0 & x$UM == 0 & x$UU == 0, NA, sqrt(1 / x$MM + 1 / x$MU + 1 / x$UM + 1 / x$MU))
}
return(data.frame(lor = lor, ase = ase))
}
#' Computes aggregated log odds ratios from the CpG-pairs object. Aggregation can be done by intra-pair distance (IPD) and/or number of intervening CpGs (NIC). By default it aggregates by IPD.
#'
#' @param x is a "WF" object storing CpG-pairs
#' @param strand is subsets x by strand - 'combined', 'OT' or 'OB'.
#' @param ipd is TRUE or FALSE. Should tables be aggregated by intra-pair distance
#' @param nic is TRUE or FALSE. Should tables be aggregated by the number of intervening CpGs (NIC) in the CpG-pair
#' @param cpgs is a GRanges instance of all CpGs in the reference/sample. Must be defined if nic = TRUE.
#' @param correct is TRUE or FALSE. Should a continuity correction be performed for computation of log odds ratios
#'
#' @return a data.frame containing aggregated log odds ratio (and asymptotic standard errors) for each strata.
#' @keywords WF, lor
#' @export
#' @examples
#' NULL
aggregatedLor <- function(x, ipd = TRUE, nic = FALSE, cpgs, correct = FALSE){
if(ipd){
ipd.values <- width(x) - 1 # -1 to make neighbouring CpGs (CGCG) have IPD = 2
} else{
ipd.values <- rep(-1, length(x)) # -1 is a FLAG that the
}
if(nic){
nic.values <- countOverlaps(x, cpgs) - 2 # All CpG-pairs overlap 2 CpGs by definition; therefore need to subtract 2 to get NIC
} else{
nic.values <- rep(-1, length(x))
}
y <- values(x)
aggregated <- aggregate.data.frame(x = data.frame(MM = y$MM, MU = y$MU, UM = y$UM, UU = y$UU), by = list(IPD = ipd.values, NIC = nic.values), FUN = sum)
# Replace -1 flags with NAs
aggregated$IPD[aggregated$IPD == -1] <- NA
aggregated$NIC[aggregated$NIC == -1] <- NA
# Compute log odds ratios and their asymptotic standard errors
aggregated.lors <- cbind(IPD = aggregated$IPD, NIC = aggregated$NIC, lor(aggregated, correct = correct))
return(aggregated.lors)
}
# Quantile plot of LORs as a function of a intra-pair separation from the WF.gr instance
#' Plot a quantile plot of individual CpG-pair log odds ratios as a function of IPD
#'
#' @param cpg.pairs is a GRanges instance of CpG-pairs and their associated log odds ratios
#' @param sample.name is a string of the sample's name
#' @param min.cov is the miniumum coverage required for a CpG-pair to be included in the plot
#'
#' @return NULL
#' @keywords WF, lor
#' @export
#' @examples
#' NULL
lorQuantilePlot <- function(cpg.pairs, sample.name, min.cov){
cpg.pairs <- cpg.pairs[values(cpg.pairs)$cov >= min.cov, ]
# A nasty kludge here to ensure q has the correct colnames. The tmp object is some bastard-hybrid of a 2 column data.frame, where the second column (x) is a named vector.
tmp <- aggregate.data.frame(x = values(cpg.pairs)$lor, by = list(IPD = width(cpg.pairs) - 1), FUN = function(x){quantile(x, c(0.1, 0.25, 0.5, 0.75, 0.9), na.rm = TRUE, names = FALSE)})
q <- as.data.frame(cbind(tmp$IPD, tmp$x))
names(q) <- c('IPD', 'Q10', 'Q25', 'Q50', 'Q75', 'Q90')
# q <- ddply(data.frame(IPD = width(cpg.pairs) - 1, lor = values(cpg.pairs)$lor), .variables = c('IPD'), function(x){quantile(x$lor, c(0.1, 0.25, 0.5, 0.75, 0.9), na.rm = TRUE)}, .parallel = FALSE) # Can do this in one step (and faster) with plyr
# Reshape q from "wide" form to "long" form
q.long <- melt(q, id.vars = 'IPD', variable.name = 'Quantile', value.name = 'lor')
# Plot
qplot(x = IPD, y = lor, lty = Quantile, data = q.long, geom = "line", main = paste0(sample.name, ': WF-comethylation (n = ', length(cpg.pairs), ')'), ylab = "Log odds ratio", xlab = "Distance between CpGs (bp)") + scale_linetype_manual(name="Quantile",  values=c('Q10' = 3, 'Q25' = 2, 'Q50' = 1, 'Q75' = 2, 'Q90' = 3)) + presentation.theme
}
#' Density plot of all log odds ratios at a given IPD (can be multiple IPDs).
#'
#' @param cpg.pairs is a GRanges instance of CpG-pairs and their associated log odds ratios
#' @param sample.name is a string of the sample's name
#' @param min.cov is the miniumum coverage required for a CpG-pair to be included in the plot
#' @param ipd is a vector of IPD values. A density plot is generated for each IPD so it's best not to use to many (<7).
#' @param pair.type is the type of CpG-pairs. For example, outermost or all and neighbouring or overlapping. This is purely descriptive and is only used in plot titles.
#'
#' @return NULL
#' @keywords WF, lor
#' @export
#' @examples
#' NULL
lorDensityPlot <- function(cpg.pairs, sample.name, min.cov, ipd, pair.type){
# TODO: Make colour a continuous scale rather than discrete so I can use a colour gradient rather than qualtitative colours
# TODO: Fix x-axis limits
cpg.pairs <- cpg.pairs[values(cpg.pairs)$cov >= min.cov, ]
cpg.pairs <- cpg.pairs[(width(cpg.pairs) - 1) %in% ipd, ]
tmp <- data.frame(lor = values(cpg.pairs)$lor, IPD = (width(cpg.pairs) - 1))
m <- ggplot(tmp, aes(x = lor, colour = factor(IPD)))
m + geom_density(size = 2) + ggtitle(substitute(paste(sample.name, ' (pair-type = ', pair.type, '): min.cov = ', min.cov, sep = ''), list(sample.name = sample.name, pair.type = pair.type, min.cov = min.cov))) + scale_colour_discrete(name = 'IPD') + presentation.theme
}
?plyr::rbind.fill
qplot(1:10, geom = 'line', lwd = 1.2)
library(ggplot2)
qplot(1:10, geom = 'line', lwd = 1.2)
qplot(1:10, geom = 'line')
qplot(1:10, 1:10, geom = 'line')
qplot(1:10, 1:10, geom = 'line', lwd = 1.2)
qplot(1:10, 1:10, geom = 'line', lwd = 1.1)
qplot(1:10, 1:10, geom = 'line', lwd = 10.6)
qplot(1:10, 1:10, geom = 'line', lwd = 0.6)
qplot(1:10, 1:10, geom = 'line', size = 0.5)
qplot(1:10, 1:10, geom = 'line', size = 1.6)
plot(1:10, 1:10, 'l', lwd = 1)
plot(1:10, 1:10, 'l', lwd = 2)
plot(1:10, 1:10, 'l', lwd = 4)
qplot(1:10, 1:10, geom = 'line', size = I(1.5))
qplot(1:10, 1:10, geom = 'line', size = I(1))
qplot(1:10, 1:10, geom = 'line', size = I(2))
?legend.key.size
16.9/10/5
16.9/10.5
16/10
library(GenomicRanges)
library(GenomicRanges)
?subsetByOverlaps
ggfluctuation(table(movies$Action, movies$Comedy))
library(ggplot2)
ggfluctuation(table(movies$Action, movies$Comedy))
ggpcp(mtcars) + geom_line()# ggpcp(mtcars, vars=names(mtcars[2:6])) + geom_line()
mmissing <- movies
mmissing[sample(nrow(movies), 1000), sample(ncol(movies), 5)] <- NA
ggmissing(mmissing)# ggmissing(mmissing, order=FALSE, missing.only = FALSE)# ggmissing(mmissing, avoid="dodge") + scale_y_sqrt()
ggstructure(mtcars)
mean_se(rpois(1000, 10))
mean_se
library(GenomicRanges)
library(ggplot2)
aggregatedLor <- function(x, ipd = TRUE, nic = FALSE, cpgs, correct = FALSE){
if(ipd){
ipd.values <- width(x) - 1 # -1 to make neighbouring CpGs (CGCG) have IPD = 2
} else{
ipd.values <- rep(-1, length(x)) # -1 is a FLAG that the
}
if(nic){
nic.values <- elementMetadata(x)$NIC
} else{
nic.values <- rep(-1, length(x))
}
y <- values(x)
aggregated <- aggregate.data.frame(x = data.frame(MM = y$MM, MU = y$MU, UM = y$UM, UU = y$UU), by = list(IPD = ipd.values, NIC = nic.values), FUN = sum)
# Replace -1 flags with NAs
aggregated$IPD[aggregated$IPD == -1] <- NA
aggregated$NIC[aggregated$NIC == -1] <- NA
# Compute log odds ratios and their asymptotic standard errors
aggregated.lors <- cbind(IPD = aggregated$IPD, NIC = aggregated$NIC, lor(aggregated, correct = correct))
return(aggregated.lors)
}
aggregatedLor <- function(x, ipd = TRUE, nic = FALSE, correct = FALSE){
if(ipd){
ipd.values <- width(x) - 1 # -1 to make neighbouring CpGs (CGCG) have IPD = 2
} else{
ipd.values <- rep(-1, length(x)) # -1 is a FLAG that the
}
if(nic){
nic.values <- elementMetadata(x)$NIC
} else{
nic.values <- rep(-1, length(x))
}
y <- values(x)
aggregated <- aggregate.data.frame(x = data.frame(MM = y$MM, MU = y$MU, UM = y$UM, UU = y$UU), by = list(IPD = ipd.values, NIC = nic.values), FUN = sum)
# Replace -1 flags with NAs
aggregated$IPD[aggregated$IPD == -1] <- NA
aggregated$NIC[aggregated$NIC == -1] <- NA
# Compute log odds ratios and their asymptotic standard errors
aggregated.lors <- cbind(IPD = aggregated$IPD, NIC = aggregated$NIC, lor(aggregated, correct = correct))
return(aggregated.lors)
}
aggregateLorPlot <- function(lor.df, sample.name, zero.nic, pair.choice, genomic.feature = NA, ...){
if(zero.nic){
my.title <- paste0(sample.name, ': aggregated within-fragment comethylation\npair.choice = ', pair.choice, ', NIC = 0')
} else{
my.title <- my.title <- paste0(sample.name, ': aggregated within-fragment comethylation\npair.choice = ', pair.choice)
}
if(!is.na(genomic.feature)){
my.title <- paste0(my.title, ', ', genomic.feature)
}
qplot(x = IPD, y = lor, data = lor.df, size = I(1.2), main = my.title, ylab = "Log odds ratio", xlab = "Distance between CpGs (bp)", ...) + presentation.theme
}
devtools::load_all(".")
?new.env
library(GRanges)
library(GenomicRanges)
library(GenomicRanges)
?findOverlaps
?quantile
?ggtitle
library(ggplot2)
?ggtitle
library(ggplot2)
?scale_x_continuous
a <- 'Lowly methylated regions'
?grepl
library(stringr)
?stringr
?str_detect
str_detect('regions', a)
a
str_detect(a, 'regions')
str_extract(a, 'regions')
str_extract(a, ^'regions')
str_extract(a, '^regions')
str_split(a, 'regions')
str_split(a, ' regions')
str_split(a, ' regions')[[1]]
str_split(a, ' regions')[[1]][1]
?str_split
str_split_fixed(a, ' regions')
str_split_fixed(a, ' regions', n = 1)
str_split_fixed(a, ' regions', n = 2)
dat <- data.frame(x=1, xend=5, y=1, yend=2)
p <- ggplot(dat, aes(x=x, xend=xend, y=y, yend=yend)) + geom_segment()
p
p + scale_x_continuous(limits=c(1,2))
library(scales)
p + scale_x_continuous(limits=c(1,2), oob=squish)
p + scale_x_continuous(limits=c(1,2), oob=rescale_none)
qplot(1:10, 1:10) + scale_x_continuous(limits=c(4,7)) +
coord_cartesian(xlim=c(0,11))
qplot(1:10, 1:10) + scale_x_continuous(limits=c(4,7), oob=rescale_none) +
coord_cartesian(xlim=c(0,11))
library(GenomicRanges)
devtools::load_all(".")
